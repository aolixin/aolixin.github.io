<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello This is aolixin</title>
    <url>/2024/12/17/hello-world/</url>
    <content><![CDATA[<p>本人是一个在游戏开发领域奋斗的同学, 本站是一些个人的学习记录&amp;学习笔记</p>
<p>关键词如下</p>
<ul>
<li>Unity &amp; Unreal</li>
<li>c++ &amp; c#</li>
<li>图形学 &amp; 渲染</li>
<li>lua, Typescript</li>
<li>其他杂七杂八的内容</li>
</ul>
<p>因为是个人学习笔记, 对于一些东西理解有限, 也可能有纰漏和错误, 看到的话欢迎指正 ~</p>
<p>如果有些内容帮到你, 十分荣幸 ~</p>
]]></content>
      <categories>
        <category>aolixin</category>
      </categories>
  </entry>
  <entry>
    <title>UE 类型系统 (一)</title>
    <url>/2024/12/31/UE%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F_1/</url>
    <content><![CDATA[<h1 id="UE-类型系统-一"><a href="#UE-类型系统-一" class="headerlink" title="UE 类型系统 (一)"></a>UE 类型系统 (一)</h1><p>如题, 这是一篇关于 UE 类型系统的学习笔记, 有很多个人理解, 或许有不准确或者错误的地方, 如果有人看到, 欢迎指正</p>
<p><strong>主要参考大钊博客</strong> –&gt; <a href="https://www.zhihu.com/people/fjz13">https://www.zhihu.com/people/fjz13</a></p>
<p>首先, 类型系统有什么用呢?</p>
<p>GC，反射，序列化 ……</p>
<p>可见, 类型系统是游戏引擎中很重要的基石</p>
<span id="more"></span>



<h2 id="HUT-UBT"><a href="#HUT-UBT" class="headerlink" title="HUT UBT"></a>HUT UBT</h2><p>首先从这个看起</p>
<p>UE 的 GC 采用的方案是工具生成这么个方案</p>
<p>解释一下就是: 在C++源文件中用空的宏做标记，然后用UHT分析生成generated.h&#x2F;.cpp文件，之后再一起编译。</p>
<p>一些常用的宏: UCLASS, USTRUCT, UFUNCTION, UPROPERTY, UENUM</p>
<p><strong>试验一下</strong></p>
<p>先看最常用的 UObject</p>
<p>新建一个 UObject类, 命名为 UAlxObject</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Fill out your copyright notice in the Description page of Project Settings.</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;CoreMinimal.h&quot;</span><br><span class="line">#include &quot;UObject/Object.h&quot;</span><br><span class="line">#include &quot;AlxObject.generated.h&quot;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class TESTPROJ1_API UAlxObject : public UObject</span><br><span class="line">&#123;</span><br><span class="line">   GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">   UPROPERTY()</span><br><span class="line">   int data1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>编译一下生成了 AlxObject.generated.h 和 AlxObject.generated.cpp</p>
<p><strong>AlxObject.generated.h</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Copyright Epic Games, Inc. All Rights Reserved.</span><br><span class="line">/*===========================================================================</span><br><span class="line">   Generated code exported from UnrealHeaderTool.</span><br><span class="line">   DO NOT modify this manually! Edit the corresponding .h files instead!</span><br><span class="line">===========================================================================*/</span><br><span class="line"></span><br><span class="line">// IWYU pragma: private, include &quot;AlxObject.h&quot;</span><br><span class="line">#include &quot;UObject/ObjectMacros.h&quot;</span><br><span class="line">#include &quot;UObject/ScriptMacros.h&quot;</span><br><span class="line"></span><br><span class="line">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">#ifdef TESTPROJ1_AlxObject_generated_h</span><br><span class="line">#error &quot;AlxObject.generated.h already included, missing &#x27;#pragma once&#x27; in AlxObject.h&quot;</span><br><span class="line">#endif</span><br><span class="line">#define TESTPROJ1_AlxObject_generated_h</span><br><span class="line"></span><br><span class="line">#define FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_INCLASS_NO_PURE_DECLS \</span><br><span class="line">private: \</span><br><span class="line">   static void StaticRegisterNativesUAlxObject(); \</span><br><span class="line">   friend struct Z_Construct_UClass_UAlxObject_Statics; \</span><br><span class="line">public: \</span><br><span class="line">   DECLARE_CLASS(UAlxObject, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT(&quot;/Script/TestProj1&quot;), NO_API) \</span><br><span class="line">   DECLARE_SERIALIZER(UAlxObject)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_ENHANCED_CONSTRUCTORS \</span><br><span class="line">   /** Standard constructor, called after all reflected properties have been initialized */ \</span><br><span class="line">   NO_API UAlxObject(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get()); \</span><br><span class="line">private: \</span><br><span class="line">   /** Private move- and copy-constructors, should never be used */ \</span><br><span class="line">   UAlxObject(UAlxObject&amp;&amp;); \</span><br><span class="line">   UAlxObject(const UAlxObject&amp;); \</span><br><span class="line">public: \</span><br><span class="line">   DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UAlxObject); \</span><br><span class="line">   DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UAlxObject); \</span><br><span class="line">   DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UAlxObject) \</span><br><span class="line">   NO_API virtual ~UAlxObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_12_PROLOG</span><br><span class="line">#define FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_GENERATED_BODY \</span><br><span class="line">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span><br><span class="line">public: \</span><br><span class="line">   FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_INCLASS_NO_PURE_DECLS \</span><br><span class="line">   FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_ENHANCED_CONSTRUCTORS \</span><br><span class="line">private: \</span><br><span class="line">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;&gt; TESTPROJ1_API UClass* StaticClass&lt;class UAlxObject&gt;();</span><br><span class="line"></span><br><span class="line">#undef CURRENT_FILE_ID</span><br><span class="line">#define CURRENT_FILE_ID FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br></pre></td></tr></table></figure>



<p><strong>AlxObject.generated.cpp</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Copyright Epic Games, Inc. All Rights Reserved.</span><br><span class="line">/*===========================================================================</span><br><span class="line">   Generated code exported from UnrealHeaderTool.</span><br><span class="line">   DO NOT modify this manually! Edit the corresponding .h files instead!</span><br><span class="line">===========================================================================*/</span><br><span class="line"></span><br><span class="line">#include &quot;UObject/GeneratedCppIncludes.h&quot;</span><br><span class="line">#include &quot;TestProj1/AlxObject.h&quot;</span><br><span class="line">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">void EmptyLinkFunctionForGeneratedCodeAlxObject() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// Begin Cross Module References</span><br><span class="line">COREUOBJECT_API UClass* Z_Construct_UClass_UObject();</span><br><span class="line">TESTPROJ1_API UClass* Z_Construct_UClass_UAlxObject();</span><br><span class="line">TESTPROJ1_API UClass* Z_Construct_UClass_UAlxObject_NoRegister();</span><br><span class="line">UPackage* Z_Construct_UPackage__Script_TestProj1();</span><br><span class="line">// End Cross Module References</span><br><span class="line"></span><br><span class="line">// Begin Class UAlxObject</span><br><span class="line">void UAlxObject::StaticRegisterNativesUAlxObject()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">IMPLEMENT_CLASS_NO_AUTO_REGISTRATION(UAlxObject);</span><br><span class="line">UClass* Z_Construct_UClass_UAlxObject_NoRegister()</span><br><span class="line">&#123;</span><br><span class="line">   return UAlxObject::StaticClass();</span><br><span class="line">&#125;</span><br><span class="line">struct Z_Construct_UClass_UAlxObject_Statics</span><br><span class="line">&#123;</span><br><span class="line">#if WITH_METADATA</span><br><span class="line">   static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = &#123;</span><br><span class="line">#if !UE_BUILD_SHIPPING</span><br><span class="line">      &#123; &quot;Comment&quot;, &quot;/**\n * \n */&quot; &#125;,</span><br><span class="line">#endif</span><br><span class="line">      &#123; &quot;IncludePath&quot;, &quot;AlxObject.h&quot; &#125;,</span><br><span class="line">      &#123; &quot;ModuleRelativePath&quot;, &quot;AlxObject.h&quot; &#125;,</span><br><span class="line">   &#125;;</span><br><span class="line">   static constexpr UECodeGen_Private::FMetaDataPairParam NewProp_data1_MetaData[] = &#123;</span><br><span class="line">      &#123; &quot;ModuleRelativePath&quot;, &quot;AlxObject.h&quot; &#125;,</span><br><span class="line">   &#125;;</span><br><span class="line">#endif // WITH_METADATA</span><br><span class="line">   static const UECodeGen_Private::FIntPropertyParams NewProp_data1;</span><br><span class="line">   static const UECodeGen_Private::FPropertyParamsBase* const PropPointers[];</span><br><span class="line">   static UObject* (*const DependentSingletons[])();</span><br><span class="line">   static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = &#123;</span><br><span class="line">      TCppClassTypeTraits&lt;UAlxObject&gt;::IsAbstract,</span><br><span class="line">   &#125;;</span><br><span class="line">   static const UECodeGen_Private::FClassParams ClassParams;</span><br><span class="line">&#125;;</span><br><span class="line">const UECodeGen_Private::FIntPropertyParams Z_Construct_UClass_UAlxObject_Statics::NewProp_data1 = &#123; &quot;data1&quot;, nullptr, (EPropertyFlags)0x0010000000000000, UECodeGen_Private::EPropertyGenFlags::Int, RF_Public|RF_Transient|RF_MarkAsNative, nullptr, nullptr, 1, STRUCT_OFFSET(UAlxObject, data1), METADATA_PARAMS(UE_ARRAY_COUNT(NewProp_data1_MetaData), NewProp_data1_MetaData) &#125;;</span><br><span class="line">const UECodeGen_Private::FPropertyParamsBase* const Z_Construct_UClass_UAlxObject_Statics::PropPointers[] = &#123;</span><br><span class="line">   (const UECodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UClass_UAlxObject_Statics::NewProp_data1,</span><br><span class="line">&#125;;</span><br><span class="line">static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UAlxObject_Statics::PropPointers) &lt; 2048);</span><br><span class="line">UObject* (*const Z_Construct_UClass_UAlxObject_Statics::DependentSingletons[])() = &#123;</span><br><span class="line">   (UObject* (*)())Z_Construct_UClass_UObject,</span><br><span class="line">   (UObject* (*)())Z_Construct_UPackage__Script_TestProj1,</span><br><span class="line">&#125;;</span><br><span class="line">static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UAlxObject_Statics::DependentSingletons) &lt; 16);</span><br><span class="line">const UECodeGen_Private::FClassParams Z_Construct_UClass_UAlxObject_Statics::ClassParams = &#123;</span><br><span class="line">   &amp;UAlxObject::StaticClass,</span><br><span class="line">   nullptr,</span><br><span class="line">   &amp;StaticCppClassTypeInfo,</span><br><span class="line">   DependentSingletons,</span><br><span class="line">   nullptr,</span><br><span class="line">   Z_Construct_UClass_UAlxObject_Statics::PropPointers,</span><br><span class="line">   nullptr,</span><br><span class="line">   UE_ARRAY_COUNT(DependentSingletons),</span><br><span class="line">   0,</span><br><span class="line">   UE_ARRAY_COUNT(Z_Construct_UClass_UAlxObject_Statics::PropPointers),</span><br><span class="line">   0,</span><br><span class="line">   0x001000A0u,</span><br><span class="line">   METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UAlxObject_Statics::Class_MetaDataParams), Z_Construct_UClass_UAlxObject_Statics::Class_MetaDataParams)</span><br><span class="line">&#125;;</span><br><span class="line">UClass* Z_Construct_UClass_UAlxObject()</span><br><span class="line">&#123;</span><br><span class="line">   if (!Z_Registration_Info_UClass_UAlxObject.OuterSingleton)</span><br><span class="line">   &#123;</span><br><span class="line">      UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UAlxObject.OuterSingleton, Z_Construct_UClass_UAlxObject_Statics::ClassParams);</span><br><span class="line">   &#125;</span><br><span class="line">   return Z_Registration_Info_UClass_UAlxObject.OuterSingleton;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt; TESTPROJ1_API UClass* StaticClass&lt;UAlxObject&gt;()</span><br><span class="line">&#123;</span><br><span class="line">   return UAlxObject::StaticClass();</span><br><span class="line">&#125;</span><br><span class="line">UAlxObject::UAlxObject(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) &#123;&#125;</span><br><span class="line">DEFINE_VTABLE_PTR_HELPER_CTOR(UAlxObject);</span><br><span class="line">UAlxObject::~UAlxObject() &#123;&#125;</span><br><span class="line">// End Class UAlxObject</span><br><span class="line"></span><br><span class="line">// Begin Registration</span><br><span class="line">struct Z_CompiledInDeferFile_FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_Statics</span><br><span class="line">&#123;</span><br><span class="line">   static constexpr FClassRegisterCompiledInInfo ClassInfo[] = &#123;</span><br><span class="line">      &#123; Z_Construct_UClass_UAlxObject, UAlxObject::StaticClass, TEXT(&quot;UAlxObject&quot;), &amp;Z_Registration_Info_UClass_UAlxObject, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UAlxObject), 531443262U) &#125;,</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">static FRegisterCompiledInInfo Z_CompiledInDeferFile_FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_1518281140(TEXT(&quot;/Script/TestProj1&quot;),</span><br><span class="line">   Z_CompiledInDeferFile_FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_Statics::ClassInfo, UE_ARRAY_COUNT(Z_CompiledInDeferFile_FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_Statics::ClassInfo),</span><br><span class="line">   nullptr, 0,</span><br><span class="line">   nullptr, 0);</span><br><span class="line">// End Registration</span><br><span class="line">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br></pre></td></tr></table></figure>



<p>尝试理解一下这两个文件</p>
<p>从 .h 的 **GENERATED_BODY() **开始, 这个宏做了一些替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY);</span><br><span class="line"></span><br><span class="line">#define BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)</span><br><span class="line"></span><br><span class="line">#define BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ol>
<li><strong>CURRENT_FILE_ID</strong> 定义在 .gen.h 中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define CURRENT_FILE_ID FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>_<em>Line</em> _ 是 c 标准库里的东西</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;__LINE__&lt;&lt;std::endl; // output -- 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最终经过几层替换, 生成了一个这个 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_GENERATED_BODY</span><br></pre></td></tr></table></figure>

<p>然后这个宏再做替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_GENERATED_BODY \</span><br><span class="line">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span><br><span class="line">public: \</span><br><span class="line">   FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_INCLASS_NO_PURE_DECLS \</span><br><span class="line">   FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_ENHANCED_CONSTRUCTORS \</span><br><span class="line">private: \</span><br><span class="line">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br></pre></td></tr></table></figure>

<p>其中, 关注    FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_INCLASS_NO_PURE_DECLS <br>   FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_ENHANCED_CONSTRUCTORS \ 这两个宏</p>
<p>先看 FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_INCLASS_NO_PURE_DECLS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_INCLASS_NO_PURE_DECLS \</span><br><span class="line">private: \</span><br><span class="line">   static void StaticRegisterNativesUAlxObject(); \</span><br><span class="line">   friend struct Z_Construct_UClass_UAlxObject_Statics; \</span><br><span class="line">public: \</span><br><span class="line">   DECLARE_CLASS(UAlxObject, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT(&quot;/Script/TestProj1&quot;), NO_API) \</span><br><span class="line">   DECLARE_SERIALIZER(UAlxObject)</span><br></pre></td></tr></table></figure>

<p>分析一下: </p>
<ol>
<li><strong>StaticRegisterNativesUAlxObject</strong>:</li>
</ol>
<p>空函数</p>
<ol start="2">
<li><strong>Z_Construct_UClass_UAlxObject_Statics</strong>:</li>
</ol>
<p>这个的话, 是一个友元结构体, 其定义可以在 gen.cpp 中找到</p>
<p>这个结构体是一个数据类, 定义了一些 static const 类型的变量, 以我们 UAlxObject  为例, 他生成了如下的变量</p>
<p>因为这些变量是 static const 类型变量, 所以会在运行开始时就初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// metadata</span><br><span class="line">static constexpr UECodeGen_Private::FMetaDataPairParam NewProp_data1_MetaData[] = &#123;</span><br><span class="line">   &#123; &quot;ModuleRelativePath&quot;, &quot;AlxObject.h&quot; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const UECodeGen_Private::FPropertyParamsBase* const PropPointers[]; // 存储所有 prop</span><br><span class="line">static const UECodeGen_Private::FIntPropertyParams NewProp_data1; // 存储 data1 的信息</span><br><span class="line">static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = &#123;</span><br><span class="line">	TCppClassTypeTraits&lt;UAlxObject&gt;::IsAbstract,</span><br><span class="line">&#125;;</span><br><span class="line">static const UECodeGen_Private::FClassParams ClassParams; // class 本身的信息</span><br></pre></td></tr></table></figure>

<p>这些变量类型都在 UObjectGlobal.h 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct FGenericPropertyParams // : FPropertyParamsBaseWithOffset</span><br><span class="line">   &#123;</span><br><span class="line">      const char*      NameUTF8;</span><br><span class="line">      const char*       RepNotifyFuncUTF8;</span><br><span class="line">      EPropertyFlags    PropertyFlags;</span><br><span class="line">      EPropertyGenFlags Flags;</span><br><span class="line">      EObjectFlags     ObjectFlags;</span><br><span class="line">      SetterFuncPtr  SetterFunc;</span><br><span class="line">      GetterFuncPtr  GetterFunc;</span><br><span class="line">      uint16           ArrayDim;</span><br><span class="line">      uint16           Offset;</span><br><span class="line">#if WITH_METADATA</span><br><span class="line">      uint16                              NumMetaData;</span><br><span class="line">      const FMetaDataPairParam*           MetaDataArray;</span><br><span class="line">#endif</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   typedef FGenericPropertyParams FIntPropertyParams;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   struct FClassParams</span><br><span class="line">   &#123;</span><br><span class="line">		UClass*                                   (*ClassNoRegisterFunc)();</span><br><span class="line">		const char*                                 ClassConfigNameUTF8;</span><br><span class="line">		const FCppClassTypeInfoStatic*              CppClassInfo;</span><br><span class="line">		UObject*                           (*const *DependencySingletonFuncArray)();</span><br><span class="line">		const FClassFunctionLinkInfo*               FunctionLinkArray;</span><br><span class="line">		const FPropertyParamsBase* const*           PropertyArray;</span><br><span class="line">		const FImplementedInterfaceParams*          ImplementedInterfaceArray;</span><br><span class="line">		uint32                                      NumDependencySingletons : 4;</span><br><span class="line">		uint32                                      NumFunctions : 11;</span><br><span class="line">		uint32                                      NumProperties : 11;</span><br><span class="line">		uint32                                      NumImplementedInterfaces : 6;</span><br><span class="line">		uint32                                      ClassFlags; // EClassFlags</span><br><span class="line">#if WITH_METADATA</span><br><span class="line">		uint16                                      NumMetaData;</span><br><span class="line">		const FMetaDataPairParam*                   MetaDataArray;</span><br><span class="line">#endif</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>DECLARE_CLASS</strong></li>
</ol>
<p>这是个非常非常重要的宏</p>
<p>DECLARE_CLASS 定义在 ObjectMacros.h 中, 他定义了一些重载函数, 一些类的信息, 包括最最常用的 <strong>StaticClass()</strong></p>
<p>然后, 现在我们明白了, StaticClass() 的原理就是: 调用 GetPrivateStaticClass() 构建一个装有这个类型信息的 UClass*, 然后返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define DECLARE_CLASS( TClass, TSuperClass, TStaticFlags, TStaticCastFlags, TPackage, TRequiredAPI  ) \</span><br><span class="line">private: \</span><br><span class="line">    TClass&amp; operator=(TClass&amp;&amp;);   \</span><br><span class="line">    TClass&amp; operator=(const TClass&amp;);   \</span><br><span class="line">   TRequiredAPI static UClass* GetPrivateStaticClass(); \</span><br><span class="line">public: \</span><br><span class="line">   /** Bitwise union of #EClassFlags pertaining to this class.*/ \</span><br><span class="line">   static constexpr EClassFlags StaticClassFlags=EClassFlags(TStaticFlags); \</span><br><span class="line">   /** Typedef for the base class (&#123;&#123; typedef-type &#125;&#125;) */ \</span><br><span class="line">   typedef TSuperClass Super;\</span><br><span class="line">   /** Typedef for &#123;&#123; typedef-type &#125;&#125;. */ \</span><br><span class="line">   typedef TClass ThisClass;\</span><br><span class="line">   /** Returns a UClass object representing this class at runtime */ \</span><br><span class="line">   inline static UClass* StaticClass() \</span><br><span class="line">   &#123; \</span><br><span class="line">      return GetPrivateStaticClass(); \</span><br><span class="line">   &#125; \</span><br><span class="line">   /** Returns the package this class belongs in */ \</span><br><span class="line">   inline static const TCHAR* StaticPackage() \</span><br><span class="line">   &#123; \</span><br><span class="line">      return TPackage; \</span><br><span class="line">   &#125; \</span><br><span class="line">   /** Returns the static cast flags for this class */ \</span><br><span class="line">   inline static EClassCastFlags StaticClassCastFlags() \</span><br><span class="line">   &#123; \</span><br><span class="line">      return TStaticCastFlags; \</span><br><span class="line">   &#125; \</span><br><span class="line">   /** For internal use only; use StaticConstructObject() to create new objects. */ \</span><br><span class="line">   inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \</span><br><span class="line">   &#123; \</span><br><span class="line">      return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \</span><br><span class="line">   &#125; \</span><br><span class="line">   /** For internal use only; use StaticConstructObject() to create new objects. */ \</span><br><span class="line">   inline void* operator new( const size_t InSize, EInternal* InMem ) \</span><br><span class="line">   &#123; \</span><br><span class="line">      return (void*)InMem; \</span><br><span class="line">   &#125; \</span><br><span class="line">   /* Eliminate V1062 warning from PVS-Studio while keeping MSVC and Clang happy. */ \</span><br><span class="line">   inline void operator delete(void* InMem) \</span><br><span class="line">   &#123; \</span><br><span class="line">      ::operator delete(InMem); \</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>再看 FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_ENHANCED_CONSTRUCTORS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define FID_Documents_work_unrealProject_TestProj1_Source_TestProj1_AlxObject_h_15_ENHANCED_CONSTRUCTORS \</span><br><span class="line">   /** Standard constructor, called after all reflected properties have been initialized */ \</span><br><span class="line">   NO_API UAlxObject(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get()); \</span><br><span class="line">private: \</span><br><span class="line">   /** Private move- and copy-constructors, should never be used */ \</span><br><span class="line">   UAlxObject(UAlxObject&amp;&amp;); \</span><br><span class="line">   UAlxObject(const UAlxObject&amp;); \</span><br><span class="line">public: \</span><br><span class="line">   DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UAlxObject); \</span><br><span class="line">   DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UAlxObject); \</span><br><span class="line">   DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UAlxObject) \</span><br><span class="line">   NO_API virtual ~UAlxObject();</span><br></pre></td></tr></table></figure>



<p>这个宏的话貌似就是声明了一些构造函数和析构函数</p>
<p>后面还没看, 先这样 –&gt; 对戛然而止做解释</p>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>c++ friend 关键字</title>
    <url>/2024/12/31/friend%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="c-friend-关键字小实验"><a href="#c-friend-关键字小实验" class="headerlink" title="c++ friend 关键字小实验"></a>c++ friend 关键字小实验</h2><p>在看 UE 类型系统的时候, 看到这样一句话</p>
<p>“<strong>UE为每个类生成了一个专门的反射数据收集类，以友元类的方式来访问类信息”</strong></p>
<p>也发觉自己怎么用过 friend 这个关键字</p>
<p>于是做点小实验, 直接上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mian.cpp </span><br><span class="line">// friend class and friend function</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class AClass</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int data_private;</span><br><span class="line">protected:</span><br><span class="line">    int data_protected;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    AClass(int a, int b): data_private(a), data_protected(b)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // declare friend class</span><br><span class="line">    friend class AClass_friend;</span><br><span class="line">    friend void show_friend(AClass&amp; a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BClass: public AClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BClass(int a, int b): AClass(a, b)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AClass_friend</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void show_friend(AClass&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;a.data_private&lt;&lt;&#x27; &#x27;&lt;&lt;a.data_protected&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void show_friend(AClass&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;a.data_private&lt;&lt;&#x27; &#x27;&lt;&lt;a.data_protected&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    AClass a(10, 20);</span><br><span class="line">    show_friend(a);</span><br><span class="line"></span><br><span class="line">    BClass b(30, 40);</span><br><span class="line">    show_friend(b);</span><br><span class="line"></span><br><span class="line">    AClass_friend af;</span><br><span class="line">    af.show_friend(a);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>new delete placement 以及他们在继承关系中的调用顺序</title>
    <url>/2024/12/29/new%20delete%20placement%20%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E5%9C%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="new-delete-placement-以及他们在继承关系中的调用顺序"><a href="#new-delete-placement-以及他们在继承关系中的调用顺序" class="headerlink" title="new delete placement 以及他们在继承关系中的调用顺序"></a>new delete placement 以及他们在继承关系中的调用顺序</h1><p>直接看代码</p>
<p>分析:</p>
<p><strong>不涉及继承关系时</strong>, 调用顺序是:</p>
<p>op new —&gt; constructor —&gt; destructor —&gt; op delete</p>
<p><strong>有继承关系时</strong>:</p>
<p>derived op new —&gt;base constructor —&gt;derived constructor —&gt;</p>
<p>derived destructor —&gt; base destructor —&gt; derived op delete</p>
<p><strong>子类不管是 new 还是 delete, 只调用一次子类的 op new &amp; delete</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mian.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(): <span class="built_in">data</span>(<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new &amp; placement</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base operator new&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base placement new&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base operator delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">void</span>* place)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base placement delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new &amp; placement</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived operator new&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived placement new&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived operator delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">void</span>* place)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived placement delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int data;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// new &amp; delete</span></span><br><span class="line">    Base* pBase = <span class="keyword">new</span> Base;</span><br><span class="line">    <span class="keyword">delete</span> pBase;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    Derived* pDerived = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> pDerived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="comment">// Base operator new</span></span><br><span class="line">    <span class="comment">// Base constructor</span></span><br><span class="line">    <span class="comment">// Base destructor</span></span><br><span class="line">    <span class="comment">// Base operator delete</span></span><br><span class="line">    <span class="comment">// --------------------------</span></span><br><span class="line">    <span class="comment">// Derived operator new</span></span><br><span class="line">    <span class="comment">// Base constructor</span></span><br><span class="line">    <span class="comment">// Derived constructor</span></span><br><span class="line">    <span class="comment">// Derived destructor</span></span><br><span class="line">    <span class="comment">// Base destructor</span></span><br><span class="line">    <span class="comment">// Derived operator delete</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>static 和 extern</title>
    <url>/2024/12/28/static%20%E5%92%8C%20extern/</url>
    <content><![CDATA[<h2 id="static变量初始化个人理解"><a href="#static变量初始化个人理解" class="headerlink" title="static变量初始化个人理解:"></a><strong>static变量初始化个人理解:</strong></h2><p>其实一共就两种</p>
<p>要么在编译时或者加载时初始化, 这两种要在类外进行赋值 —&gt; <strong>静态初始化</strong></p>
<p>要么就在函数里初始化, 这种就是运行时初始化, 推荐用这个, 不用在类外进行赋值 —&gt; <strong>动态初始化</strong></p>
<p>上面的个人理解不准确, 要注意: 函数中也可以静态初始化, 初始化参数是常量这种</p>
<ol>
<li>编译时初始化</li>
<li>加载时初始化</li>
<li>运行时初始化<ol>
<li>怎么实现的</li>
<li>用 static 变量之后的一个32位地址标记是否已经初始化过了</li>
<li>局部 static 变量不是线程安全的, 因为上述操作不是原子操作</li>
<li>c++11 之后为什么线程安全了呢? 因为并发时候, 会阻塞其他线程</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">5</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> y = x;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 看是不是初始化过了</span></span><br><span class="line">        <span class="type">int</span> *p = &amp;y;</span><br><span class="line">        p++;</span><br><span class="line">        *p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="static-函数可以是-virtual-吗"><a href="#static-函数可以是-virtual-吗" class="headerlink" title="static 函数可以是 virtual 吗?"></a><strong>static 函数可以是 virtual 吗?</strong></h2><p>不能, 因为普通类成员函数是有一个 this 指针的, 但是 static 函数没有this指针</p>
<h2 id="static-和-extern"><a href="#static-和-extern" class="headerlink" title="static 和 extern"></a>static 和 extern</h2><p>看例子</p>
<p><strong>结果分析:</strong></p>
<p>对于POD类型, 这种静态变量是在编译时初始化, 也就是静态初始化</p>
<p>而类对象这种是运行时才初始化, 所以地址肯定是一样的</p>
<p><strong>static 变量在多个cpp文件里的地址不同, 所以只是一个拷贝</strong></p>
<p><strong>extern 生命可以有很多个, 但是定义只能有一个</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mian.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> extern_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">show_static</span>();</span><br><span class="line">    <span class="built_in">show_static2</span>();</span><br><span class="line">    static_var = <span class="number">30</span>;</span><br><span class="line">    cout&lt;&lt;static_var&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;&amp;static_var&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">show_extern</span>();</span><br><span class="line">    <span class="built_in">show_extern2</span>();</span><br><span class="line">    extern_var = <span class="number">30</span>;</span><br><span class="line">    cout&lt;&lt;extern_var&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;&amp;extern_var&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">show_singleton1</span>();</span><br><span class="line">    <span class="built_in">show_singleton2</span>();</span><br><span class="line">    singleton* p = singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// 10 00007FF6A1F0F17C</span></span><br><span class="line">    <span class="comment">// 20 00007FF6A1F0F188</span></span><br><span class="line">    <span class="comment">// 30 00007FF6A1F0F174</span></span><br><span class="line">    <span class="comment">// 10 00007FF6A1F0F170</span></span><br><span class="line">    <span class="comment">// 20 00007FF6A1F0F170</span></span><br><span class="line">    <span class="comment">// 30 00007FF6A1F0F170</span></span><br><span class="line">    <span class="comment">// 00007FF6A1F0F180</span></span><br><span class="line">    <span class="comment">// 00007FF6A1F0F180</span></span><br><span class="line">    <span class="comment">// 00007FF6A1F0F180</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head.h</span></span><br><span class="line"><span class="meta"># <span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_var;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> extern_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_static</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_static2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_extern</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_extern2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_singleton1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_singleton2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">singleton</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_static</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    static_var = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;static_var&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;&amp;static_var&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_extern</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    extern_var = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;extern_var&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;&amp;extern_var&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_singleton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    singleton* p = singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_static2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    static_var = <span class="number">20</span>;</span><br><span class="line">    cout&lt;&lt;static_var&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;&amp;static_var&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_extern2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    extern_var = <span class="number">20</span>;</span><br><span class="line">    cout&lt;&lt;extern_var&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;&amp;extern_var&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_singleton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    singleton* p = singleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>clash 公司内网环境下, 配置代理</title>
    <url>/2024/12/21/clash/</url>
    <content><![CDATA[<p>起因是公司是内网环境, 只支持访问国内的一些网站</p>
<p>为了科学上网, 公司给出了一个 chrome 的插件, 通过插件去配置浏览器代理</p>
<p>但是当我用 Epic Games 在线下载 UE 的时候, 速度实在感人, 问了公司 IT 同学, IT 那边说让我去申请公司海外 vpn, 这太麻烦了!</p>
<p>于是乎, 我选择了自己配置代理软件</p>
<p>我自己笔记本用的是 clash for windows 这个代理软件</p>
<p>我在公司电脑上配置好了之后, 成功解决全局代理的问题</p>
<p>但是, 另一个问题发生了, 公司内网进不去了 !!!</p>
<p>公司的 OA 系统, 包括一些 wiki, 都是在内网环境的 !!!, 为什么配置代理之后进不去了呢?</p>
<p>于是我脑海中第一个解决办法是, 配置分流规则, 在访问公司内网的时候, 直接连接, 而不是走代理, 这个可以很方便的在 clash 内配置</p>
<img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20241221184908513.png" alt="image-20241221184908513" style="zoom: 50%;" />

<img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20241221185018730.png" alt="image-20241221185018730" style="zoom:50%;" />



<p>也可以打开配置文件, 手动配置, 这里就不演示了</p>
<p>但是当我配置完之后, 竟然没有用 !!!</p>
<p>我很奇怪啊, 于是把 clash Proxies 切换成  Global, 还是进不去, why why why</p>
<p>于是在前辈们的指导下, 我去查日志, 发现, 原来是 DNS 有问题 !</p>
<p>公司是内网环境, 有自己的 DNS 服务器, 而 clash 有自己的 DNS 服务器, 这我的 IP 解析是失败的</p>
<p>于是乎, 我查啊查, 发现, clash 有个 Mixin 功能, 可以在 clash DNS 基础上, 配置自己的 DNS 服务器</p>
<p>所以解决方案如下</p>
<ol>
<li>在 “网络和 Internet” 下, 查看自己的 DNS 服务器地址</li>
<li>配置到 clash Mixin 中 –&gt; <a href="https://blog.csdn.net/YoungHong1992/article/details/133862017">https://blog.csdn.net/YoungHong1992/article/details/133862017</a></li>
</ol>
<img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20241221190002349.png" alt="image-20241221190002349" style="zoom: 50%;" />



<p>最后最后, 我们成功地, 在保留外网访问能力的同时, 畅通的访问公司内网</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>typora + 阿里云oss搭建个人博客</title>
    <url>/2024/10/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>-- 敖立鑫 本文使用下列方案完成</p>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><ol>
<li>首先购买阿里云服务器</li>
<li>使用宝塔搭建网站</li>
<li>构建 wordpress 一键博客搭建工具</li>
<li>购买阿里云 oss 作为图床</li>
<li>下载 picGo</li>
<li>配置图床设置</li>
<li>typora 下载支持 picGo插件</li>
<li>本地用 typora 编写markdown</li>
<li>最后用 publish markdown 上传到 wordpress</li>
</ol>
<p>测试图片 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281108280.png" alt="image-20231028110817496"></p>
]]></content>
      <categories>
        <category>aolixin</category>
      </categories>
  </entry>
  <entry>
    <title>clion 编译 lua</title>
    <url>/2024/10/04/clion-%E7%BC%96%E8%AF%91-lua/</url>
    <content><![CDATA[<h1 id="clion-编译-lua"><a href="#clion-编译-lua" class="headerlink" title="clion 编译 lua"></a>clion 编译 lua</h1><h2 id="下载-lua-源码"><a href="#下载-lua-源码" class="headerlink" title="下载 lua 源码"></a>下载 lua 源码</h2><p><a href="https://www.lua.org/source/">https://www.lua.org/source/</a></p>
<h2 id="配置-clion"><a href="#配置-clion" class="headerlink" title="配置 clion"></a>配置 clion</h2><p>这里用的是 MinGW 编译器</p>
<p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20241004141044585.png" alt="image-20241004141044585"></p>
<h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><ol>
<li><p>随便新建一个 c++ 可执行文件项目</p>
</li>
<li><p>将 lua 源码拷贝到项目目录下</p>
</li>
</ol>
<p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20241004141205312.png" alt="image-20241004141205312"></p>
<h2 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h2><h3 id="修改-CMakeLists-txt"><a href="#修改-CMakeLists-txt" class="headerlink" title="修改 CMakeLists.txt"></a>修改 CMakeLists.txt</h3><p>别人写好的 cmake 文件, 可以直接拿来用<br>lua 5.1 cmake 文件 - <a href="https://gist.github.com/squeek502/76fb065848897138a95d11f9aa0eedd4">https://gist.github.com/squeek502/76fb065848897138a95d11f9aa0eedd4</a><br>lua 5.3 cmake 文件 - <a href="https://gist.github.com/squeek502/0706332efb18edd0601a4074762b0b9a">https://gist.github.com/squeek502/0706332efb18edd0601a4074762b0b9a</a></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>直接点击 [构建&#x2F;构建项目] 就好了</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20241004141647392.png" alt="image-20241004141647392"></p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
  </entry>
  <entry>
    <title>jenkins + unity 自动打包</title>
    <url>/2024/05/15/jenkins-unity-%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="jenkins-unity-自动打包"><a href="#jenkins-unity-自动打包" class="headerlink" title="jenkins + unity 自动打包"></a>jenkins + unity 自动打包</h1><h2 id="配置-java-环境"><a href="#配置-java-环境" class="headerlink" title="配置 java 环境"></a>配置 java 环境</h2><p>没啥问题</p>
<h2 id="配置-jenkins"><a href="#配置-jenkins" class="headerlink" title="配置 jenkins"></a>配置 jenkins</h2><p>开始一直显示 waiting,在查找解决办法的过程中自己好了</p>
<h2 id="执行-bat-命令"><a href="#执行-bat-命令" class="headerlink" title="执行 bat 命令"></a>执行 bat 命令</h2><p>没啥问题</p>
<h2 id="调用-python-脚本"><a href="#调用-python-脚本" class="headerlink" title="调用 python 脚本"></a>调用 python 脚本</h2><p>开始掉用不了, 切换了工作目录就行了</p>
<h2 id="unity-内打包"><a href="#unity-内打包" class="headerlink" title="unity 内打包"></a>unity 内打包</h2><p>Editor 扩展静态函数</p>
<h2 id="bat-调用-unity-静态函数"><a href="#bat-调用-unity-静态函数" class="headerlink" title="bat 调用 unity 静态函数"></a>bat 调用 unity 静态函数</h2><p>踩坑:如果不是默认命名空间,参数得加上命名空间</p>
<h2 id="python-调用-unity-打包"><a href="#python-调用-unity-打包" class="headerlink" title="python 调用 unity 打包"></a>python 调用 unity 打包</h2><p>本质还是通过 bat 调用 unity 静态函数,不过 python 更加灵活了一点</p>
<p>很坑很坑的一点, python 调用 bat 时候格式要求很严格</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>图形学处理旋转</title>
    <url>/2024/02/19/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%84%E7%90%86%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="敖立鑫"><a href="#敖立鑫" class="headerlink" title="-- 敖立鑫"></a>-- 敖立鑫</h1><h2 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h2><p><strong>优点</strong></p>
<ul>
<li>简单</li>
<li>直观</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>根据旋转顺序的不同,会导致不同的结果</p>
</li>
<li><p>会导致万向节死锁</p>
</li>
<li><p>万向节死锁举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先确定手机的物体坐标系朝向，假设z轴与手机屏幕垂直（手机平放于桌面）指向上方，手机较短的一条边为x轴，较长的一条边为y轴（方向由手机尾部指向头部），物体坐标系的原点是手机左下角的顶点。（注意旋转顺序为zyx）绕z轴旋转任意角度（注意x和y轴也跟着一起旋转），再绕y轴旋转90°，再绕x轴旋转任意角度。通过多次尝试，会发现一个共同点：z轴永远是水平的， 通俗的说，手机永远也不会立起来（旋转形成的三维空间是固定的）！本来以为手机会指向任何方向，但实际上手机好像是被锁在桌面上，只能指向水平的某个方向，这个现象就称为万向锁。而如果绕y轴旋转不等于90°（1°也好89°也好），只要选择适当的绕x和z的角度，就可以让手机指向三维空间中的任何一个方向，手机是自由的（旋转产生的三维空间不会完全重叠），也就不会遇到万向锁现象。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="轴角"><a href="#轴角" class="headerlink" title="轴角"></a>轴角</h2><p>轴角的出现是为了避免万向节死锁问题 表示为 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219202739051.png" alt="image-20240219202739051"> R(n,θ) 为旋转矩阵 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219192444630.png" alt="image-20240219192444630"> 推导过程 —&gt;<a href="https://blog.csdn.net/u014265928/article/details/117170481">【机器人学】绕空间任意轴的旋转矩阵推导_绕任意轴旋转的旋转矩阵-CSDN博客</a></p>
<h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><p>四元数主要是为了方便轴角的计算</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>四元数是一种复数的拓展 一个四元数有如下形式： <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219202758348.png" alt="image-20240219202758348"> 其中，w 为实部，x，y，z为虚部</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219202840427.png" alt="image-20240219202840427"></p>
<h3 id="处理旋转时"><a href="#处理旋转时" class="headerlink" title="处理旋转时:"></a>处理旋转时:</h3><ol>
<li><strong>将待旋转 向量&#x2F;点 转换成纯四元数</strong></li>
</ol>
<p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219202901373.png" alt="image-20240219202901373"></p>
<ol start="2">
<li><strong>根据轴角求出表示的旋转四元数 q</strong></li>
</ol>
<ul>
<li>假设旋转用轴角表示为 (x，y，z，<em>θ)</em>, θ 的范围 [ -pi,pi ]</li>
</ul>
<p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219202926482.png" alt="image-20240219202926482"> <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219195101320.png" alt="image-20240219195101320"></p>
<ol start="3">
<li><strong>计算 q 的共轭四元数 q</strong>*</li>
</ol>
<p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219202949520.png" alt="image-20240219202949520"></p>
<ol start="4">
<li><strong>根据公式 v′′&#x3D;qv′q∗ 求出结果</strong></li>
</ol>
<p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image-20240219203006435.png" alt="image-20240219203006435"></p>
<ol start="5">
<li><strong>将上述过程转换为矩阵形式</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190312200542768.png" alt="img"> <strong>c++ 实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 旋转变换，围绕 (x, y, z) 矢量旋转 theta 角度</span><br><span class="line">inline static Mat4x4f matrix_set_rotate(float x, float y, float z, float theta) &#123;</span><br><span class="line">float qsin = (float)sin(theta * 0.5f);</span><br><span class="line">float qcos = (float)cos(theta * 0.5f);</span><br><span class="line">float w = qcos;</span><br><span class="line">Vec3f vec = vector_normalize(Vec3f(x, y, z));</span><br><span class="line">x = vec.x * qsin;</span><br><span class="line">y = vec.y * qsin;</span><br><span class="line">z = vec.z * qsin;</span><br><span class="line">Mat4x4f m;</span><br><span class="line">m.data[0][0] = 1 - 2 * y * y - 2 * z * z;</span><br><span class="line">m.data[1][0] = 2 * x * y - 2 * w * z;</span><br><span class="line">m.data[2][0] = 2 * x * z + 2 * w * y;</span><br><span class="line">m.data[0][1] = 2 * x * y + 2 * w * z;</span><br><span class="line">m.data[1][1] = 1 - 2 * x * x - 2 * z * z;</span><br><span class="line">m.data[2][1] = 2 * y * z - 2 * w * x;</span><br><span class="line">m.data[0][2] = 2 * x * z - 2 * w * y;</span><br><span class="line">m.data[1][2] = 2 * y * z + 2 * w * x;</span><br><span class="line">m.data[2][2] = 1 - 2 * x * x - 2 * y * y;</span><br><span class="line">m.data[0][3] = m.data[1][3] = m.data[2][3] = 0.0f;</span><br><span class="line">m.data[3][0] = m.data[3][1] = m.data[3][2] = 0.0f;</span><br><span class="line">m.data[3][3] = 1.0f;</span><br><span class="line">return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推导见 —&gt; <a href="https://blog.csdn.net/u014265928/article/details/117161701">【机器人学】四元数与旋转矩阵的相互转换_四元数转旋转矩阵-CSDN博客</a></p>
<h2 id="四元数-和-旋转矩阵对比"><a href="#四元数-和-旋转矩阵对比" class="headerlink" title="四元数 和 旋转矩阵对比"></a>四元数 和 旋转矩阵对比</h2><ul>
<li>四元数在计算机内更紧凑</li>
<li>四元数用 4 个变量即可表示旋转,而轴角旋转矩阵需要 9 个</li>
<li>四元数计算效率更高</li>
</ul>
]]></content>
      <categories>
        <category>Rendering</category>
      </categories>
  </entry>
  <entry>
    <title>c++ 软渲染器</title>
    <url>/2024/02/13/%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8/</url>
    <content><![CDATA[<h1 id="软光栅"><a href="#软光栅" class="headerlink" title="软光栅"></a>软光栅</h1><h2 id="简介-特征"><a href="#简介-特征" class="headerlink" title="简介&amp;特征"></a>简介&amp;特征</h2><ul>
<li>实现标准渲染管线</li>
<li>底层绘图采用 GDI+</li>
<li>着色器由 c++ 编写</li>
<li>坐标系采用 directX 标准</li>
<li>实现 Vector&#x2F;Matrix 数学库, 包括常用矢量算法和矩阵算法</li>
<li>实现 DDA, Bresenham 画线算法</li>
<li>光栅化参数用重心插值</li>
<li>实现 [ blinn-phong光照模型 ] 和 [ Gouraud光照模型 ]</li>
<li>实现 obj 模型工具库</li>
<li>加载 tga 纹理工具库</li>
<li>实现 [ 双线性插值 ] 和 [ 双三次插值 ] 纹理采样算法</li>
<li>实现 mipmap</li>
<li>实现 msaa 抗锯齿算法</li>
</ul>
<p>具体细节看 –&gt; <a href="https://github.com/aolixin/ToyRenderer">https://github.com/aolixin/ToyRenderer</a></p>
]]></content>
      <categories>
        <category>Rendering</category>
      </categories>
  </entry>
  <entry>
    <title>unity 实现 PBR</title>
    <url>/2023/11/08/unity%20pbr/</url>
    <content><![CDATA[<p>-- 敖立鑫</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>unity shder 几种渲染模式 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202311081443441.png" alt="img"> 这里使用前向渲染管线 通过在 Tags中添加 “LightMode” &#x3D; “ForwardBase” 选择渲染模式 ForwrdBase</p>
<ul>
<li>基础光照计算：漫反射，镜面反射，阴影计算等</li>
<li>考虑所有光源</li>
<li>计算平行光</li>
</ul>
<p>ForwrdAdd</p>
<ul>
<li>额外的光照效果：逐像素的操作</li>
<li>默认计算 前四个最重要的 点光源</li>
</ul>
<p>这里我们只用一个平行光，暂时只用 ForwrdBase</p>
<h2 id="搭建场景"><a href="#搭建场景" class="headerlink" title="搭建场景"></a>搭建场景</h2><p>首先新建一个场景，使用 hdrp 管线 替换 material <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202311081444582.png" alt="image-20231104213410160"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="先实现一个-blinn-phong-光照模型"><a href="#先实现一个-blinn-phong-光照模型" class="headerlink" title="先实现一个 blinn-phong 光照模型"></a>先实现一个 blinn-phong 光照模型</h3><p>因为我们要实现更好的效果，不考虑性能，所以我们的光照计算都将在 frag shader 进行 首先新建一个 unlitShader <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202311081444026.png" alt="image-20231105194100976"></p>
<h3 id="添加-pbr"><a href="#添加-pbr" class="headerlink" title="添加 pbr"></a>添加 pbr</h3><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>有多种 brdf 模型 我们这里主要实现 Cook-Torrance BRDF Cook-Torrance BRDF 分为漫反射和镜面反射两个部分 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202311081444201.png" alt="image-20231106085634950"> 漫反射采用 lambertian 漫反射， <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202311081455852.png"> 镜面反射主要有三个函数 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202311081444161.png" alt="image-20231106085839814"></p>
<ul>
<li><strong>D 法线分布函数</strong>：表示反射光强度在法线附件的分布，微平面向量和面法向越接近，强度越大。通过粗糙度改变波瓣形状<ul>
<li>近似表示了微平面与半程向量的一致的比率</li>
</ul>
</li>
<li><strong>G 几何函数</strong>：表示掠视时的几何遮蔽，通过史密斯法叠加入射和出射两个方向</li>
<li><strong>F 菲涅尔方程</strong>：表示菲涅尔效应，掠视金属时反射较多的光而俯视时反射光较少</li>
</ul>
<h4 id="CG-实现"><a href="#CG-实现" class="headerlink" title="CG 实现"></a>CG 实现</h4><p>法线分布函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 法线分布函数</span><br><span class="line">// 法线，半程向量，粗糙度</span><br><span class="line">float D_GGX_TR( fixed3 N, fixed3 H, float a)</span><br><span class="line">&#123;</span><br><span class="line">    float a2 = a * a;</span><br><span class="line">    float NdotH = max(dot(N,H),0);</span><br><span class="line">    float NdotH2 = NdotH * NdotH;</span><br><span class="line"></span><br><span class="line">    float nom = a2;</span><br><span class="line">    float denom = ( NdotH2 * (a2 - 1.0) + 1.0 );</span><br><span class="line">    denom = PI * denom * denom;</span><br><span class="line">    return nom / denom;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 几何方程</span><br><span class="line">float GeometrySchlickGGX(float NdotV, float roughness )</span><br><span class="line">&#123;</span><br><span class="line">    float r = (roughness + 1.0);</span><br><span class="line">    float k = (r*r) / 8.0;</span><br><span class="line"></span><br><span class="line">    float num   = NdotV;</span><br><span class="line">    float denom = NdotV * (1.0 - k) + k;</span><br><span class="line"></span><br><span class="line">    return num / denom;</span><br><span class="line">&#125;</span><br><span class="line">float GeometrySmith(fixed3 N, fixed3 V, fixed3 L, float roughness)</span><br><span class="line">&#123;</span><br><span class="line">    float NdotV = max(dot(N, V), 0.0);</span><br><span class="line">    float NdotL = max(dot(N, L), 0.0);</span><br><span class="line">    float ggx1 = GeometrySchlickGGX(NdotV, roughness);</span><br><span class="line">    float ggx2 = GeometrySchlickGGX(NdotL, roughness);</span><br><span class="line"></span><br><span class="line">    return ggx1 * ggx2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 菲涅尔方程</span><br><span class="line">// cosTheta -- Normal dot viewDir  F0 -- 表面颜色，反射率</span><br><span class="line">fixed3 fresnelSchlick(float cosTheta , fixed3 F0)</span><br><span class="line">&#123;</span><br><span class="line"> return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0) , 5.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果不太好，以后有时间再优化 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202311081444360.png" alt="image-20231108144102376"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/31766439">笔记九——渲染路径&amp;复杂光照 - 知乎 (zhihu.com)</a> <a href="https://blog.csdn.net/u014078887/article/details/117308741">UnityShader-平行光和点光源的基础介绍和使用_unity_4lightposx0-CSDN博客</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>xlua 和 unity 判空踩的坑</title>
    <url>/2023/11/01/lua%20%E5%88%A4%E7%A9%BAbug/</url>
    <content><![CDATA[<p>--敖立鑫</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有些对象在 c# 删掉了，但是 lua 不知道</p>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>判断对象为空可以用下面这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function IsNil(obj)</span><br><span class="line">return obj == nil or obj:Equals(nil)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_33205561/article/details/120952915">Lua下对gameObject判空</a></p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
  </entry>
  <entry>
    <title>unity SRP</title>
    <url>/2023/10/28/SRP/</url>
    <content><![CDATA[<p>-- 敖立鑫 2023.10.18开始，工程放在：<a href="https://github.com/aolixin/ToyRenderPipeline">github</a> <a href="https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/">Custom Render Pipeline (catlikecoding.com)</a> – 基于这个教程</p>
<h2 id="srp渲染流程"><a href="#srp渲染流程" class="headerlink" title="srp渲染流程"></a>srp渲染流程</h2><ul>
<li>渲染流程<ul>
<li>创建commandBuffer</li>
<li>用buffer执行命令（配置buffer）如:buffer.ClearRenderTarget(true, true, Color.clear);</li>
<li>用context（上下文）执行buffer</li>
<li>清除buffer</li>
</ul>
</li>
<li>context<ul>
<li>可以直接执行一些命令如context.DrawSkybox(camera);</li>
<li>也可以执行commandBuffer</li>
</ul>
</li>
</ul>
<h3 id="drawingSettings"><a href="#drawingSettings" class="headerlink" title="drawingSettings"></a>drawingSettings</h3><ul>
<li>里面有一些渲染设置<ul>
<li><strong>渲染排序设置（SortingSettings）</strong>：<ul>
<li>可以设置渲染对象的排序方式，以控制绘制顺序，包括前向渲染（Forward Rendering）和透明对象的排序。</li>
<li>你可以定义绘制对象的排序层级、渲染队列、渲染模式等。</li>
</ul>
</li>
<li><strong>着色器通道设置（ShaderPassName）</strong>：<ul>
<li>可以指定要使用的着色器通道，以定义如何渲染对象。</li>
<li>这包括了渲染效果、材质属性、着色器功能等。</li>
</ul>
</li>
<li><strong>Override Material（覆盖材质）</strong>：<ul>
<li>可以指定一个材质来覆盖对象的原始材质，从而实现特定的渲染效果或外观变化。</li>
</ul>
</li>
<li><strong>光照设置（Lighting Settings）</strong>：<ul>
<li>可以设置是否启用光照，以及如何应用光照。</li>
<li>这包括了是否启用实时阴影、光照模式等。</li>
</ul>
</li>
<li><strong>剔除（Culling）设置</strong>：<ul>
<li>可以定义剔除设置，包括视锥体剔除、遮挡剔除等，以减少渲染的开销。</li>
</ul>
</li>
<li><strong>渲染队列（Rendering Layer）</strong>：<ul>
<li>可以指定要渲染的渲染队列，用于将对象分类并在不同阶段渲染</li>
</ul>
</li>
</ul>
</li>
<li>比如：drawingSettings.SetShaderPassName(1, litShaderTagId);<ul>
<li>修改着色器通道</li>
<li>感觉类似于 opengl 中的shader.use()</li>
</ul>
</li>
</ul>
<h3 id="ScriptableCullingParameters"><a href="#ScriptableCullingParameters" class="headerlink" title="ScriptableCullingParameters"></a>ScriptableCullingParameters</h3><p><code>ScriptableCullingParameters</code> 是Unity中的一个类，用于表示和配置裁剪（culling）过程的参数。裁剪是渲染管线中的一个关键步骤，用于确定哪些对象在摄像机的视锥体内可见，以减少不必要的渲染工作。<code>ScriptableCullingParameters</code> 允许你配置裁剪参数，以满足渲染需求。 这个类通常用于与自定义渲染管线（如SRP，Scriptable Render Pipeline）一起使用，以更好地控制渲染过程。以下是一些 <code>ScriptableCullingParameters</code> 类的常见属性和用途：</p>
<ul>
<li>**<code>layerFarCullDistances</code> 和 <code>layerCullDistances</code>**：这些属性允许你为不同的图层配置远裁剪距离。这是一个优化技巧，可以根据图层将视锥体外的对象排除在渲染之外。</li>
<li>**<code>cullingPlane</code> 和 <code>cullingPlaneCount</code>**：你可以配置自定义裁剪平面，以进一步调整视锥体的形状。这对于创建非标准的裁剪区域非常有用。</li>
<li>**<code>isOrthographic</code> 和 <code>projectionMatrix</code>**：这些属性用于指定摄像机是正交投影还是透视投影，并设置投影矩阵。这对于不同类型的摄像机配置非常重要。</li>
<li>**<code>layerMask</code> 和 <code>sceneMask</code>**：你可以配置要裁剪的图层和场景，以过滤视锥体内的对象。</li>
<li>**<code>maximumVisibleLights</code>**：这个属性用于指定在裁剪期间能够处理的最大可见光源数量。</li>
<li>**<code>shadowDistance</code> 和 <code>screenSpaceShadowRes</code>**：这些属性用于配置阴影渲染的参数，以便在裁剪期间生成阴影。</li>
<li>**<code>lodBias</code>**：这个属性用于指定层次渐进细节（LOD）偏差，以在裁剪期间控制物体的细节级别。</li>
</ul>
<p><code>ScriptableCullingParameters</code> 类的实例通常会在渲染管线的裁剪阶段使用，以确定可见对象并将其传递给渲染阶段。这个类允许开发人员在自定义渲染管线中更好地控制裁剪过程，以优化性能和满足特定需求。</p>
<h2 id="srp-中ugui绘制"><a href="#srp-中ugui绘制" class="headerlink" title="srp 中ugui绘制"></a>srp 中ugui绘制</h2><p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452180.png" alt="image-20231018201531240"> <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452429.png" alt="image-20231018201545395"> 当render mode是overlay时，ugui渲染不归srp管，把render mode调成camera，并把render target调成 自己的camera，就归管线管了 – 会被归到透明几何体的绘制 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452941.png" alt="image-20231018202044570"></p>
<h2 id="unity-批处理-Unity渲染优化的4种批处理"><a href="#unity-批处理-Unity渲染优化的4种批处理" class="headerlink" title="unity 批处理 Unity渲染优化的4种批处理"></a>unity 批处理 <a href="https://zhuanlan.zhihu.com/p/432223843">Unity渲染优化的4种批处理</a></h2><ul>
<li>静态批处理<ul>
<li>将物体设置为static，静态批处理不一定减少DrawCall，但是会让CPU在“设置渲染状态-提交Draw Call”上更高效</li>
<li>为什么不手动合并mesh，因为假如手动合并，在视锥体剔除时，只要出现一个三角形，那么视锥体剔除就不会剔除掉</li>
<li>条件<ul>
<li>使用相同材质引用的静态物体</li>
<li>物体需为Mesh，具有MeshFilter和MeshRenderer组件</li>
<li>Mesh 需要在ImportSettings面板勾选【read&#x2F;write enabled】</li>
</ul>
</li>
</ul>
</li>
<li>动态批处理<ul>
<li>在运行时Unity自动把每一帧画面里符合条件的多个模型网格合并为一个，再传递给GPU</li>
<li>条件十分苛刻<ul>
<li><a href="https://blog.csdn.net/lengyoumo/article/details/109328193">unity静动态批处理的触发条件以及无效的问题解决办法</a></li>
</ul>
</li>
</ul>
</li>
<li>SRP batcher（相同shader，不同mat）<ul>
<li>对于结构相同的shader，可以将数据直接全部存到GPU（CBUFFER），减少状态转换，不能减少draw call</li>
<li>得看RP支不支持，shader需要支持SRP Batcher（HDRP和URP项目的Lit和Unlit shader都支持）</li>
</ul>
</li>
<li>GPU Instancing（相同mesh，相同mat）<ul>
<li>将实例数据存储到 GPU（UNITY_INSTANCING_BUFFER）</li>
<li>GPU Instancing适用于处理大量相同物体，比如建筑物&#x2F;树&#x2F;草等重复出现的物体。</li>
</ul>
</li>
</ul>
<h3 id="SRP-batcher"><a href="#SRP-batcher" class="headerlink" title="SRP batcher"></a>SRP batcher</h3><ul>
<li><p>cbuffer – hlsl中常量缓冲区 ： 常量数据可以包括变换矩阵、材质属性、光照信息等。</p>
</li>
<li><p>通过 cbuffers 实现srp batcher，将materials各种参数提前存入GPU实现</p>
</li>
<li><p>在shader中定义cbuffers</p>
<ul>
<li><pre><code>//材质cbuffer
CBUFFER_START(UnityPerMaterial)
float4 _BaseColor;
CBUFFER_END
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   ```</span><br><span class="line">    //矩阵buffer</span><br><span class="line">    CBUFFER_START(UnityPerDraw)</span><br><span class="line">    float4x4 unity_ObjectToWorld;</span><br><span class="line">    float4x4 unity_WorldToObject;</span><br><span class="line">    real4 unity_WorldTransformParams;</span><br><span class="line">    float4 unity_LODFade;</span><br><span class="line">    CBUFFER_END</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>GraphicsSettings.useScriptableRenderPipelineBatching &#x3D; true;实现绘制统一shader但是不同mat的多个物体 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452751.png" alt="image-20231020095318248"> 右边frame debugger可以看出drawSRPBatcher， 但是为每个obj添加一个新颜色只能添加一个mat，很不方便，通过脚本修改属性（renderer.SetPropertyBlock(props);）的话又退化成普通draw call</p>
</li>
</ul>
<h3 id="GPU-Instancing"><a href="#GPU-Instancing" class="headerlink" title="GPU Instancing"></a><strong>GPU Instancing</strong></h3><p><a href="https://zhuanlan.zhihu.com/p/523765931">GPU Instancing原理)</a> ####　unity 开启 GPU Instancing：</p>
<ul>
<li>build-in管线：standard shader开启GPU Instance选项</li>
<li>URP默认不支持</li>
<li>有时候GPU Instancing还是分批渲染，每批有上限 – cbuffer有上限</li>
<li><a href="https://zhuanlan.zhihu.com/p/524195324">创建支持GPU Instancing 的 shader</a></li>
<li>让每个 instance 属性独立 – MaterialPropertyBlock</li>
</ul>
<h4 id="srp-实现"><a href="#srp-实现" class="headerlink" title="srp 实现"></a>srp 实现</h4><ul>
<li>shader部分和上面大差不差</li>
<li>不过srp batcher 和 GPU Instancing不兼容，所以得先删除srp batcher部分代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Graphics.DrawMeshInstanced(mesh, 0, material, matrices, 1023, block);</span><br></pre></td></tr></table></figure>

<h3 id="srp-batcher和-GPU-Instancing区别"><a href="#srp-batcher和-GPU-Instancing区别" class="headerlink" title="srp batcher和 GPU Instancing区别"></a>srp batcher和 GPU Instancing区别</h3><ul>
<li>srp batcher（相同shader，不同mat）：传多个mesh ，传一个 block（CBUFFER） ，block里面有每个mat，每个mat用的shader必须是同一个，保证数据格式相同，状态转换不会出错</li>
<li>GPU Instancing（相同mesh，相同mat）： 传一个mesh ,传一个block（UNITY_INSTANCING_BUFFER），block有每个不同数据，相同mat，但是不同的</li>
<li>作用范围<ul>
<li>多个 shader 可以共用一个 CBUFFER，因为里面存储的光照信息等是全局相同的</li>
<li>但是一般不共用一个 UNITY_INSTANCING_BUFFE，每个 shader 主要用于存储示例数据</li>
</ul>
</li>
</ul>
<h3 id="Dynamic-Batching"><a href="#Dynamic-Batching" class="headerlink" title="Dynamic Batching"></a>Dynamic Batching</h3><p>srp实现 Dynamic Batching，优先级在srp batcher之下</p>
<ul>
<li><pre><code>//改变drawingSettings
var drawingSettings = new DrawingSettings(
unlitShaderTagId, sortingSettings
) &#123;
enableDynamicBatching = true,
enableInstancing = false
&#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line">## SRP 实现Lit shader</span><br><span class="line"></span><br></pre></td></tr></table></figure>
// 获取光源方向的反方向
dirLightDirections[index] = -visibleLight.localToWorldMatrix.GetColumn(2);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
// 一个 Instancing 缓冲区
UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
UNITY_DEFINE_INSTANCED_PROP(float4, _BaseMap_ST)
UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)
</code></pre>
</li>
</ul>
<p>UNITY_DEFINE_INSTANCED_PROP(float, _Metallic)<br>UNITY_DEFINE_INSTANCED_PROP(float, _Smoothness)</p>
<p>UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 实现（一个实现一个文件，有点面向对象的意思）</span><br><span class="line"></span><br><span class="line">*   创建自己的 lightMode</span><br><span class="line">*   修改 Render 函数</span><br><span class="line">*   修改 shaderID -- drawingSettings.SetShaderPassName</span><br><span class="line">*   创建light -- 存入cbuffer</span><br><span class="line">    *   ```</span><br><span class="line">        struct Light &#123;</span><br><span class="line">        float3 color;</span><br><span class="line">        float3 direction;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建 surface</p>
<ul>
<li><pre><code>struct Surface &#123;
float3 normal;
float3 viewDirection;
float3 color;
float alpha;

float metallic;
float smoothness;

&#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   创建 brdf</span><br><span class="line">    *   ```</span><br><span class="line">        struct BRDF &#123;</span><br><span class="line">        float3 diffuse;</span><br><span class="line">        float3 specular;</span><br><span class="line">        float roughness;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>将光照信息存在UNITY_INSTANCING_BUFFER</p>
</li>
<li><p>通过surface获取光照</p>
<ul>
<li>float3 GetLighting (Surface surface,BRDF brdf)</li>
</ul>
</li>
<li><p>brdf + litShader + direct light + GPU Instancing（还挺好看的）</p>
</li>
</ul>
<p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452684.png" alt="image-20231021210237424"></p>
<ul>
<li>加上alpha裁剪<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452764.png" alt="image-20231022101123043"></li>
</ul>
</li>
</ul>
<h2 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="file://D:\zhuomian\工作\笔记\C:%5CUsers%5Caolixin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231022110239840.png" alt="image-20231022110239840"></p>
<h3 id="生成shadowMap"><a href="#生成shadowMap" class="headerlink" title="生成shadowMap"></a>生成shadowMap</h3><ul>
<li><p><img src="https://pic4.zhimg.com/80/v2-c7108831a33744083819d7615c5bfe57_720w.webp" alt="img"></p>
</li>
<li><pre><code>// 创建一张临时纹理
buffer.GetTemporaryRT()
// 设置渲染目标
buffer.SetRenderTarget()
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   shadowSettings -- 渲染shadowMap的配置</span><br><span class="line">*   ```</span><br><span class="line">    // 获取渲染阴影时的变换矩阵，阴影分割数据等</span><br><span class="line">    cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(</span><br><span class="line">    light.visibleLightIndex, 0, 1, Vector3.zero, tileSize, 0f,</span><br><span class="line">    out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix,</span><br><span class="line">    out ShadowSplitData splitData</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>// 渲染阴影
// tips：context.DrawShadows只渲染包含ShadowCaster Pass的材质
context.DrawShadows(ref shadowSettings);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   当投射阴影的光数量大于1时候，将shadowMap分割成四分，通过 `buffer.SetViewport()` 渲染纹理的一部分（）</span><br><span class="line">*   因为上述情况，所以光照的vp矩阵得做一个映射</span><br><span class="line">    *   ```</span><br><span class="line">        // 坐标映射，这段代码害我debug了六个小时！！！</span><br><span class="line">        Matrix4x4 ConvertToAtlasMatrix(Matrix4x4 m, Vector2 offset, int split)</span><br><span class="line">        &#123;</span><br><span class="line">            //Debug.Log(&quot;split: &quot;+split);</span><br><span class="line">            //Debug.Log(&quot;offset: &quot; + offset);</span><br><span class="line">            if (SystemInfo.usesReversedZBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">            m.m20 = -m.m20;</span><br><span class="line">            m.m21 = -m.m21;</span><br><span class="line">            m.m22 = -m.m22;</span><br><span class="line">            m.m23 = -m.m23;</span><br><span class="line">            &#125;</span><br><span class="line">            // [-1,1]映射到[0,1]</span><br><span class="line">            // 坐标映射到四个子 map</span><br><span class="line">            float scale = 1f / split;</span><br><span class="line">            m.m00 = (0.5f * (m.m00 + m.m30) + offset.x * m.m30) * scale;</span><br><span class="line">            m.m01 = (0.5f * (m.m01 + m.m31) + offset.x * m.m31) * scale;</span><br><span class="line">            m.m02 = (0.5f * (m.m02 + m.m32) + offset.x * m.m32) * scale;</span><br><span class="line">            m.m03 = (0.5f * (m.m03 + m.m33) + offset.x * m.m33) * scale;</span><br><span class="line">            m.m10 = (0.5f * (m.m10 + m.m30) + offset.y * m.m30) * scale;</span><br><span class="line">            m.m11 = (0.5f * (m.m11 + m.m31) + offset.y * m.m31) * scale;</span><br><span class="line">            m.m12 = (0.5f * (m.m12 + m.m32) + offset.y * m.m32) * scale;</span><br><span class="line">            m.m13 = (0.5f * (m.m13 + m.m33) + offset.y * m.m33) * scale;</span><br><span class="line">            m.m20 = 0.5f * (m.m20 + m.m30);</span><br><span class="line">            m.m21 = 0.5f * (m.m21 + m.m31);</span><br><span class="line">            m.m22 = 0.5f * (m.m22 + m.m32);</span><br><span class="line">            m.m23 = 0.5f * (m.m23 + m.m33);</span><br><span class="line">        </span><br><span class="line">            return m;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
    
    shadowMap 的采样有说法，详情看代码
</code></pre>
</li>
<li><p>将 surface 世界坐标转换到shaowMap坐标下（通过第三步获取的转换矩阵）</p>
</li>
<li><pre><code>// unity内置宏，对shadowmap采样
TEXTURE2D_SHADOW(_DirectionalShadowAtlas);
#define SHADOW_SAMPLER sampler_linear_clamp_compare
SAMPLER_CMP(SHADOW_SAMPLER);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   获取阴影 strength 和原 color 相乘</span><br><span class="line">*   最终结果，有严重的摩尔纹</span><br><span class="line">    *   ![image-20231023183854132](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453415.png)</span><br><span class="line"></span><br><span class="line">### 级联shadowMap</span><br><span class="line"></span><br><span class="line">*   原理</span><br><span class="line">    *   ![img](https://pic1.zhimg.com/80/v2-b592f37c6cae42255ef3b3ac99a17000_1440w.webp)</span><br><span class="line">*   ```</span><br><span class="line">    // 通过修改参数获取不同的 v,p 矩阵</span><br><span class="line">    cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(</span><br><span class="line">    light.visibleLightIndex, i, cascadeCount, ratios, tileSize, 0f,</span><br><span class="line">    out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix,</span><br><span class="line">    out ShadowSplitData splitData</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

*   ![image-20231024091425837](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453673.png)
</code></pre>
</li>
<li><p>culling sphere</p>
<ul>
<li>在确定每个级联图要渲染的实际区域时，Unity会为根据级联的阴影裁剪长方体创建一个球型空间，该球形空间会包裹整个阴影裁剪长方体，因此球形的空间会比原长方体多包裹住一些空间，这可能会导致有时在裁剪长方体区域外也会绘制一些阴影。下图为Culling Spheres的可视化图。</li>
<li>Culling Spheres的作用是让Shader确定相机渲染的每个片元需要采样哪个级联图。原理很简单，对于相机要渲染的一个片元，计算出其光源空间下的坐标，通过它计算片元与每个Culling Sphere球心的距离，最后确定属于哪个球空间内，采样对应级联图。 –</li>
<li><img src="https://catlikecoding.com/unity/tutorials/custom-srp/directional-shadows/cascaded-shadow-maps/culling-spheres.png" alt="img"></li>
</ul>
</li>
<li><pre><code>// 向shader传递 cullingSphere 参数
// cullingSphere -- x,y,z,r^2
Vector4 cullingSphere = splitData.cullingSphere;
cullingSphere.w *= cullingSphere.w;
cascadeCullingSpheres[i] = cullingSphere;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   ```</span><br><span class="line">    // 每个片元对应的 联级的信息</span><br><span class="line">    struct ShadowData &#123;</span><br><span class="line">    int cascadeIndex; // 联级索引</span><br><span class="line">    float cascadeBlend; // 和下一联级混合的比例</span><br><span class="line">    float strength;// 阴影强度</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 对阴影信息的抽象</span><br><span class="line">    struct DirectionalShadowData &#123;</span><br><span class="line">    float strength;</span><br><span class="line">    int tileIndex;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>shader 中对应关系</p>
<ul>
<li>light – DirectionalShadowData</li>
<li>frag – shadowData</li>
</ul>
</li>
<li><pre><code>// 获取具体 DirectionalShadowData -- shadowMap 索引+联级偏移量
data.tileIndex = _DirectionalLightShadowData[lightIndex].y + shadowData.cascadeIndex;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   ```</span><br><span class="line">    //通过距离判断在那个culling sphere</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; _CascadeCount; i++) &#123;</span><br><span class="line">        float4 sphere = _CascadeCullingSpheres[i];</span><br><span class="line">        float distanceSqr = DistanceSquared(surfaceWS.position, sphere.xyz);</span><br><span class="line">        if (distanceSqr &lt; sphere.w) &#123;</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    data.cascadeIndex = i;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>联级可视化</p>
<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453105.png" alt="image-20231024104421040"></li>
</ul>
</li>
<li><p>超过 maxDistence 不采样</p>
<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453161.png" alt="image-20231024105330375"></li>
</ul>
</li>
<li><p>阴影随着片元在 camera view space 深度增加而变浅 + 阴影在 max cascade 逐渐变浅</p>
<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453096.png" alt="image-20231024140333611"></li>
</ul>
</li>
</ul>
<h3 id="提升阴影质量"><a href="#提升阴影质量" class="headerlink" title="提升阴影质量"></a>提升阴影质量</h3><ul>
<li><p>shadow acne（毛刺 &amp; 阴影暗斑）</p>
<ul>
<li>原理 <a href="https://zhuanlan.zhihu.com/p/366555785">关于ShadowMap中Shadow acne现象的解释</a><ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453260.png" alt="image-20231024141014255"></li>
</ul>
</li>
<li>样例<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454585.png" alt="image-20231024141002382"></li>
</ul>
</li>
<li>Depth Bias – 添加偏移buffer.SetGlobalDepthBias(50000f, 0f); – 但是会产生阴影偏移</li>
<li>Slope Bias – buffer.SetGlobalDepthBias(0,3f); – 根据斜度进行偏移<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454961.png" alt="image-20231024141915498"></li>
</ul>
</li>
<li>由于使用联级阴影，使用全局统一的bias不合理，所以需要根据联级不同，使用不同的 culling sphere 半径做法线偏移<ul>
<li><pre><code>float3 normalBias = surfaceWS.normal * _CascadeData[global.cascadeIndex].y;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">        *   ![image-20231024151624724](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454069.png)</span><br><span class="line">*   shadow pancaking （阴影平坠 ）-- 理解的不是很好，有时间再看看</span><br><span class="line">    *   原理：[Unity 阴影——阴影平坠（Shadow pancaking](https://blog.csdn.net/ithot/article/details/125473479)</span><br><span class="line">    *   给进平面添加一个偏移</span><br><span class="line"></span><br><span class="line">### 添加 PCF</span><br><span class="line"></span><br><span class="line">*   原理：[CSM, PCSS与SDF Soft Shadow](https://zhuanlan.zhihu.com/p/478472753)</span><br><span class="line">*   float4 \_ShadowAtlasSize; //（像素大小，map尺寸，0，0）</span><br><span class="line">*   SampleShadow\_ComputeSamples\_Tent\_7x7 (size, positionSTS.xy, weights, positions);计算 PCF权重weights ，采样点positions</span><br><span class="line">    *   ```</span><br><span class="line">        // 增加采样</span><br><span class="line">        for (int i = 0; i &lt; DIRECTIONAL_FILTER_SAMPLES; i++) &#123;</span><br><span class="line">        shadow += weights[i] * SampleDirectionalShadowAtlas(</span><br><span class="line">        float3(positions[i].xy, positionSTS.z)</span><br><span class="line">        );</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>buffer.EnableShaderKeyword( string ) &#x2F;&#x2F; 向shader添加关键字，常用于定义宏</p>
</li>
<li><p>联级过渡出现问题</p>
<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454840.png" alt="image-20231024214954538"></li>
<li>添加联级之间混合，效果好了，但是增加了采样次数<ul>
<li><pre><code>if (global.cascadeBlend &lt; 1.0) &#123;
normalBias = surfaceWS.normal *
(directional.normalBias * _CascadeData[global.cascadeIndex + 1].y);
positionSTS = mul(
_DirectionalShadowMatrices[directional.tileIndex + 1],
float4(surfaceWS.position + normalBias, 1.0)
).xyz;
// 联级之间根据
shadow = lerp(
FilterDirectionalShadow(positionSTS), shadow, global.cascadeBlend
);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   在采样时添加抖动</span><br><span class="line">    *   surface.dither = InterleavedGradientNoise(input.positionCS.xy, 0); //生成时间梯度噪声</span><br><span class="line">*   绘制 shadowMap 时不绘制在当前联级之外的物体</span><br><span class="line">    *   ```</span><br><span class="line">        splitData.shadowCascadeBlendCullingFactor = cullingFactor</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="阴影裁剪"><a href="#阴影裁剪" class="headerlink" title="阴影裁剪"></a>阴影裁剪</h3><ul>
<li><pre><code>// shadow caster 中裁剪
#if defined(_SHADOWS_CLIP)
  clip(base.r - UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff));
#endif
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   ![image-20231028143015906](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454867.png)</span><br><span class="line"></span><br><span class="line">![image-20231028144052590](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454629.png)</span><br><span class="line"></span><br><span class="line">## 其他</span><br><span class="line"></span><br><span class="line">### unity Input</span><br><span class="line"></span><br><span class="line">*   buffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);) 设置矩阵，然后unity Input把这个矩阵放到shader里面</span><br><span class="line"></span><br><span class="line">### unity中real变量</span><br><span class="line"></span><br><span class="line">*   unity core RP Pipline Library real -- 根据不同平台成为float或half，定义在com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl</span><br><span class="line"></span><br><span class="line">### Premultiplied Alpha (Alpha预乘)</span><br><span class="line"></span><br><span class="line">[Premultiplied Alpha到底是干嘛用的](https://blog.csdn.net/mydreamremindme/article/details/50817294) [Premultiplied Alpha Tips](https://zhuanlan.zhihu.com/p/344751308) 实现</span><br><span class="line"></span><br><span class="line">*   ```</span><br><span class="line">    // alpha 预乘</span><br><span class="line">      if (applyAlphaToDiffuse) &#123;</span><br><span class="line">      brdf.diffuse *= surface.alpha;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="unity-default"><a href="#unity-default" class="headerlink" title="unity default"></a>unity default</h3><p><code>default</code> 值的含义取决于 <code>ShadowSettings</code> 类型的定义。如果 <code>ShadowSettings</code> 是一个自定义结构或类，那么它的默认值将取决于它的构造函数或字段默认值。这样，<code>shadows</code> 字段将在Inspector中显示，并且其初始值将设置为 <code>ShadowSettings</code> 类型的默认值。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
</search>
