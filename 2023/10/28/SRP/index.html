<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="-- 敖立鑫 2023.10.18开始，工程放在：github Custom Render Pipeline (catlikecoding.com) – 基于这个教程 srp渲染流程 渲染流程 创建commandBuffer 用buffer执行命令（配置buffer）如:buffer.ClearRenderTarget(true, true, Color.clear); 用context（上下文）">
<meta property="og:type" content="article">
<meta property="og:title" content="unity SRP">
<meta property="og:url" content="http://example.com/2023/10/28/SRP/index.html">
<meta property="og:site_name" content="aolixin blog">
<meta property="og:description" content="-- 敖立鑫 2023.10.18开始，工程放在：github Custom Render Pipeline (catlikecoding.com) – 基于这个教程 srp渲染流程 渲染流程 创建commandBuffer 用buffer执行命令（配置buffer）如:buffer.ClearRenderTarget(true, true, Color.clear); 用context（上下文）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452180.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452429.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452941.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452751.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452684.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452764.png">
<meta property="og:image" content="file:///D:/zhuomian/%E5%B7%A5%E4%BD%9C/%E7%AC%94%E8%AE%B0/C:%5CUsers%5Caolixin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231022110239840.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-c7108831a33744083819d7615c5bfe57_720w.webp">
<meta property="og:image" content="https://catlikecoding.com/unity/tutorials/custom-srp/directional-shadows/cascaded-shadow-maps/culling-spheres.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453105.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453161.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453096.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453260.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454585.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454961.png">
<meta property="og:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454840.png">
<meta property="article:published_time" content="2023-10-28T07:00:04.000Z">
<meta property="article:modified_time" content="2024-12-29T02:40:30.336Z">
<meta property="article:author" content="aolixin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452180.png">

<link rel="canonical" href="http://example.com/2023/10/28/SRP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>unity SRP | aolixin blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">aolixin blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/28/SRP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aolixin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aolixin blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          unity SRP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-28 15:00:04" itemprop="dateCreated datePublished" datetime="2023-10-28T15:00:04+08:00">2023-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-29 10:40:30" itemprop="dateModified" datetime="2024-12-29T10:40:30+08:00">2024-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>-- 敖立鑫 2023.10.18开始，工程放在：<a target="_blank" rel="noopener" href="https://github.com/aolixin/ToyRenderPipeline">github</a> <a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/">Custom Render Pipeline (catlikecoding.com)</a> – 基于这个教程</p>
<h2 id="srp渲染流程"><a href="#srp渲染流程" class="headerlink" title="srp渲染流程"></a>srp渲染流程</h2><ul>
<li>渲染流程<ul>
<li>创建commandBuffer</li>
<li>用buffer执行命令（配置buffer）如:buffer.ClearRenderTarget(true, true, Color.clear);</li>
<li>用context（上下文）执行buffer</li>
<li>清除buffer</li>
</ul>
</li>
<li>context<ul>
<li>可以直接执行一些命令如context.DrawSkybox(camera);</li>
<li>也可以执行commandBuffer</li>
</ul>
</li>
</ul>
<h3 id="drawingSettings"><a href="#drawingSettings" class="headerlink" title="drawingSettings"></a>drawingSettings</h3><ul>
<li>里面有一些渲染设置<ul>
<li><strong>渲染排序设置（SortingSettings）</strong>：<ul>
<li>可以设置渲染对象的排序方式，以控制绘制顺序，包括前向渲染（Forward Rendering）和透明对象的排序。</li>
<li>你可以定义绘制对象的排序层级、渲染队列、渲染模式等。</li>
</ul>
</li>
<li><strong>着色器通道设置（ShaderPassName）</strong>：<ul>
<li>可以指定要使用的着色器通道，以定义如何渲染对象。</li>
<li>这包括了渲染效果、材质属性、着色器功能等。</li>
</ul>
</li>
<li><strong>Override Material（覆盖材质）</strong>：<ul>
<li>可以指定一个材质来覆盖对象的原始材质，从而实现特定的渲染效果或外观变化。</li>
</ul>
</li>
<li><strong>光照设置（Lighting Settings）</strong>：<ul>
<li>可以设置是否启用光照，以及如何应用光照。</li>
<li>这包括了是否启用实时阴影、光照模式等。</li>
</ul>
</li>
<li><strong>剔除（Culling）设置</strong>：<ul>
<li>可以定义剔除设置，包括视锥体剔除、遮挡剔除等，以减少渲染的开销。</li>
</ul>
</li>
<li><strong>渲染队列（Rendering Layer）</strong>：<ul>
<li>可以指定要渲染的渲染队列，用于将对象分类并在不同阶段渲染</li>
</ul>
</li>
</ul>
</li>
<li>比如：drawingSettings.SetShaderPassName(1, litShaderTagId);<ul>
<li>修改着色器通道</li>
<li>感觉类似于 opengl 中的shader.use()</li>
</ul>
</li>
</ul>
<h3 id="ScriptableCullingParameters"><a href="#ScriptableCullingParameters" class="headerlink" title="ScriptableCullingParameters"></a>ScriptableCullingParameters</h3><p><code>ScriptableCullingParameters</code> 是Unity中的一个类，用于表示和配置裁剪（culling）过程的参数。裁剪是渲染管线中的一个关键步骤，用于确定哪些对象在摄像机的视锥体内可见，以减少不必要的渲染工作。<code>ScriptableCullingParameters</code> 允许你配置裁剪参数，以满足渲染需求。 这个类通常用于与自定义渲染管线（如SRP，Scriptable Render Pipeline）一起使用，以更好地控制渲染过程。以下是一些 <code>ScriptableCullingParameters</code> 类的常见属性和用途：</p>
<ul>
<li>**<code>layerFarCullDistances</code> 和 <code>layerCullDistances</code>**：这些属性允许你为不同的图层配置远裁剪距离。这是一个优化技巧，可以根据图层将视锥体外的对象排除在渲染之外。</li>
<li>**<code>cullingPlane</code> 和 <code>cullingPlaneCount</code>**：你可以配置自定义裁剪平面，以进一步调整视锥体的形状。这对于创建非标准的裁剪区域非常有用。</li>
<li>**<code>isOrthographic</code> 和 <code>projectionMatrix</code>**：这些属性用于指定摄像机是正交投影还是透视投影，并设置投影矩阵。这对于不同类型的摄像机配置非常重要。</li>
<li>**<code>layerMask</code> 和 <code>sceneMask</code>**：你可以配置要裁剪的图层和场景，以过滤视锥体内的对象。</li>
<li>**<code>maximumVisibleLights</code>**：这个属性用于指定在裁剪期间能够处理的最大可见光源数量。</li>
<li>**<code>shadowDistance</code> 和 <code>screenSpaceShadowRes</code>**：这些属性用于配置阴影渲染的参数，以便在裁剪期间生成阴影。</li>
<li>**<code>lodBias</code>**：这个属性用于指定层次渐进细节（LOD）偏差，以在裁剪期间控制物体的细节级别。</li>
</ul>
<p><code>ScriptableCullingParameters</code> 类的实例通常会在渲染管线的裁剪阶段使用，以确定可见对象并将其传递给渲染阶段。这个类允许开发人员在自定义渲染管线中更好地控制裁剪过程，以优化性能和满足特定需求。</p>
<h2 id="srp-中ugui绘制"><a href="#srp-中ugui绘制" class="headerlink" title="srp 中ugui绘制"></a>srp 中ugui绘制</h2><p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452180.png" alt="image-20231018201531240"> <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452429.png" alt="image-20231018201545395"> 当render mode是overlay时，ugui渲染不归srp管，把render mode调成camera，并把render target调成 自己的camera，就归管线管了 – 会被归到透明几何体的绘制 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452941.png" alt="image-20231018202044570"></p>
<h2 id="unity-批处理-Unity渲染优化的4种批处理"><a href="#unity-批处理-Unity渲染优化的4种批处理" class="headerlink" title="unity 批处理 Unity渲染优化的4种批处理"></a>unity 批处理 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/432223843">Unity渲染优化的4种批处理</a></h2><ul>
<li>静态批处理<ul>
<li>将物体设置为static，静态批处理不一定减少DrawCall，但是会让CPU在“设置渲染状态-提交Draw Call”上更高效</li>
<li>为什么不手动合并mesh，因为假如手动合并，在视锥体剔除时，只要出现一个三角形，那么视锥体剔除就不会剔除掉</li>
<li>条件<ul>
<li>使用相同材质引用的静态物体</li>
<li>物体需为Mesh，具有MeshFilter和MeshRenderer组件</li>
<li>Mesh 需要在ImportSettings面板勾选【read&#x2F;write enabled】</li>
</ul>
</li>
</ul>
</li>
<li>动态批处理<ul>
<li>在运行时Unity自动把每一帧画面里符合条件的多个模型网格合并为一个，再传递给GPU</li>
<li>条件十分苛刻<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengyoumo/article/details/109328193">unity静动态批处理的触发条件以及无效的问题解决办法</a></li>
</ul>
</li>
</ul>
</li>
<li>SRP batcher（相同shader，不同mat）<ul>
<li>对于结构相同的shader，可以将数据直接全部存到GPU（CBUFFER），减少状态转换，不能减少draw call</li>
<li>得看RP支不支持，shader需要支持SRP Batcher（HDRP和URP项目的Lit和Unlit shader都支持）</li>
</ul>
</li>
<li>GPU Instancing（相同mesh，相同mat）<ul>
<li>将实例数据存储到 GPU（UNITY_INSTANCING_BUFFER）</li>
<li>GPU Instancing适用于处理大量相同物体，比如建筑物&#x2F;树&#x2F;草等重复出现的物体。</li>
</ul>
</li>
</ul>
<h3 id="SRP-batcher"><a href="#SRP-batcher" class="headerlink" title="SRP batcher"></a>SRP batcher</h3><ul>
<li><p>cbuffer – hlsl中常量缓冲区 ： 常量数据可以包括变换矩阵、材质属性、光照信息等。</p>
</li>
<li><p>通过 cbuffers 实现srp batcher，将materials各种参数提前存入GPU实现</p>
</li>
<li><p>在shader中定义cbuffers</p>
<ul>
<li><pre><code>//材质cbuffer
CBUFFER_START(UnityPerMaterial)
float4 _BaseColor;
CBUFFER_END
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   ```</span><br><span class="line">    //矩阵buffer</span><br><span class="line">    CBUFFER_START(UnityPerDraw)</span><br><span class="line">    float4x4 unity_ObjectToWorld;</span><br><span class="line">    float4x4 unity_WorldToObject;</span><br><span class="line">    real4 unity_WorldTransformParams;</span><br><span class="line">    float4 unity_LODFade;</span><br><span class="line">    CBUFFER_END</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>GraphicsSettings.useScriptableRenderPipelineBatching &#x3D; true;实现绘制统一shader但是不同mat的多个物体 <img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452751.png" alt="image-20231020095318248"> 右边frame debugger可以看出drawSRPBatcher， 但是为每个obj添加一个新颜色只能添加一个mat，很不方便，通过脚本修改属性（renderer.SetPropertyBlock(props);）的话又退化成普通draw call</p>
</li>
</ul>
<h3 id="GPU-Instancing"><a href="#GPU-Instancing" class="headerlink" title="GPU Instancing"></a><strong>GPU Instancing</strong></h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/523765931">GPU Instancing原理)</a> ####　unity 开启 GPU Instancing：</p>
<ul>
<li>build-in管线：standard shader开启GPU Instance选项</li>
<li>URP默认不支持</li>
<li>有时候GPU Instancing还是分批渲染，每批有上限 – cbuffer有上限</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/524195324">创建支持GPU Instancing 的 shader</a></li>
<li>让每个 instance 属性独立 – MaterialPropertyBlock</li>
</ul>
<h4 id="srp-实现"><a href="#srp-实现" class="headerlink" title="srp 实现"></a>srp 实现</h4><ul>
<li>shader部分和上面大差不差</li>
<li>不过srp batcher 和 GPU Instancing不兼容，所以得先删除srp batcher部分代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Graphics.DrawMeshInstanced(mesh, 0, material, matrices, 1023, block);</span><br></pre></td></tr></table></figure>

<h3 id="srp-batcher和-GPU-Instancing区别"><a href="#srp-batcher和-GPU-Instancing区别" class="headerlink" title="srp batcher和 GPU Instancing区别"></a>srp batcher和 GPU Instancing区别</h3><ul>
<li>srp batcher（相同shader，不同mat）：传多个mesh ，传一个 block（CBUFFER） ，block里面有每个mat，每个mat用的shader必须是同一个，保证数据格式相同，状态转换不会出错</li>
<li>GPU Instancing（相同mesh，相同mat）： 传一个mesh ,传一个block（UNITY_INSTANCING_BUFFER），block有每个不同数据，相同mat，但是不同的</li>
<li>作用范围<ul>
<li>多个 shader 可以共用一个 CBUFFER，因为里面存储的光照信息等是全局相同的</li>
<li>但是一般不共用一个 UNITY_INSTANCING_BUFFE，每个 shader 主要用于存储示例数据</li>
</ul>
</li>
</ul>
<h3 id="Dynamic-Batching"><a href="#Dynamic-Batching" class="headerlink" title="Dynamic Batching"></a>Dynamic Batching</h3><p>srp实现 Dynamic Batching，优先级在srp batcher之下</p>
<ul>
<li><pre><code>//改变drawingSettings
var drawingSettings = new DrawingSettings(
unlitShaderTagId, sortingSettings
) &#123;
enableDynamicBatching = true,
enableInstancing = false
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line">## SRP 实现Lit shader</span><br><span class="line"></span><br></pre></td></tr></table></figure>
// 获取光源方向的反方向
dirLightDirections[index] = -visibleLight.localToWorldMatrix.GetColumn(2);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
// 一个 Instancing 缓冲区
UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
UNITY_DEFINE_INSTANCED_PROP(float4, _BaseMap_ST)
UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)
</code></pre>
</li>
</ul>
<p>UNITY_DEFINE_INSTANCED_PROP(float, _Metallic)<br>UNITY_DEFINE_INSTANCED_PROP(float, _Smoothness)</p>
<p>UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 实现（一个实现一个文件，有点面向对象的意思）</span><br><span class="line"></span><br><span class="line">*   创建自己的 lightMode</span><br><span class="line">*   修改 Render 函数</span><br><span class="line">*   修改 shaderID -- drawingSettings.SetShaderPassName</span><br><span class="line">*   创建light -- 存入cbuffer</span><br><span class="line">    *   ```</span><br><span class="line">        struct Light &#123;</span><br><span class="line">        float3 color;</span><br><span class="line">        float3 direction;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建 surface</p>
<ul>
<li><pre><code>struct Surface &#123;
float3 normal;
float3 viewDirection;
float3 color;
float alpha;

float metallic;
float smoothness;

&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   创建 brdf</span><br><span class="line">    *   ```</span><br><span class="line">        struct BRDF &#123;</span><br><span class="line">        float3 diffuse;</span><br><span class="line">        float3 specular;</span><br><span class="line">        float roughness;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>将光照信息存在UNITY_INSTANCING_BUFFER</p>
</li>
<li><p>通过surface获取光照</p>
<ul>
<li>float3 GetLighting (Surface surface,BRDF brdf)</li>
</ul>
</li>
<li><p>brdf + litShader + direct light + GPU Instancing（还挺好看的）</p>
</li>
</ul>
<p><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452684.png" alt="image-20231021210237424"></p>
<ul>
<li>加上alpha裁剪<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281452764.png" alt="image-20231022101123043"></li>
</ul>
</li>
</ul>
<h2 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="file://D:\zhuomian\工作\笔记\C:%5CUsers%5Caolixin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231022110239840.png" alt="image-20231022110239840"></p>
<h3 id="生成shadowMap"><a href="#生成shadowMap" class="headerlink" title="生成shadowMap"></a>生成shadowMap</h3><ul>
<li><p><img src="https://pic4.zhimg.com/80/v2-c7108831a33744083819d7615c5bfe57_720w.webp" alt="img"></p>
</li>
<li><pre><code>// 创建一张临时纹理
buffer.GetTemporaryRT()
// 设置渲染目标
buffer.SetRenderTarget()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   shadowSettings -- 渲染shadowMap的配置</span><br><span class="line">*   ```</span><br><span class="line">    // 获取渲染阴影时的变换矩阵，阴影分割数据等</span><br><span class="line">    cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(</span><br><span class="line">    light.visibleLightIndex, 0, 1, Vector3.zero, tileSize, 0f,</span><br><span class="line">    out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix,</span><br><span class="line">    out ShadowSplitData splitData</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>// 渲染阴影
// tips：context.DrawShadows只渲染包含ShadowCaster Pass的材质
context.DrawShadows(ref shadowSettings);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   当投射阴影的光数量大于1时候，将shadowMap分割成四分，通过 `buffer.SetViewport()` 渲染纹理的一部分（）</span><br><span class="line">*   因为上述情况，所以光照的vp矩阵得做一个映射</span><br><span class="line">    *   ```</span><br><span class="line">        // 坐标映射，这段代码害我debug了六个小时！！！</span><br><span class="line">        Matrix4x4 ConvertToAtlasMatrix(Matrix4x4 m, Vector2 offset, int split)</span><br><span class="line">        &#123;</span><br><span class="line">            //Debug.Log(&quot;split: &quot;+split);</span><br><span class="line">            //Debug.Log(&quot;offset: &quot; + offset);</span><br><span class="line">            if (SystemInfo.usesReversedZBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">            m.m20 = -m.m20;</span><br><span class="line">            m.m21 = -m.m21;</span><br><span class="line">            m.m22 = -m.m22;</span><br><span class="line">            m.m23 = -m.m23;</span><br><span class="line">            &#125;</span><br><span class="line">            // [-1,1]映射到[0,1]</span><br><span class="line">            // 坐标映射到四个子 map</span><br><span class="line">            float scale = 1f / split;</span><br><span class="line">            m.m00 = (0.5f * (m.m00 + m.m30) + offset.x * m.m30) * scale;</span><br><span class="line">            m.m01 = (0.5f * (m.m01 + m.m31) + offset.x * m.m31) * scale;</span><br><span class="line">            m.m02 = (0.5f * (m.m02 + m.m32) + offset.x * m.m32) * scale;</span><br><span class="line">            m.m03 = (0.5f * (m.m03 + m.m33) + offset.x * m.m33) * scale;</span><br><span class="line">            m.m10 = (0.5f * (m.m10 + m.m30) + offset.y * m.m30) * scale;</span><br><span class="line">            m.m11 = (0.5f * (m.m11 + m.m31) + offset.y * m.m31) * scale;</span><br><span class="line">            m.m12 = (0.5f * (m.m12 + m.m32) + offset.y * m.m32) * scale;</span><br><span class="line">            m.m13 = (0.5f * (m.m13 + m.m33) + offset.y * m.m33) * scale;</span><br><span class="line">            m.m20 = 0.5f * (m.m20 + m.m30);</span><br><span class="line">            m.m21 = 0.5f * (m.m21 + m.m31);</span><br><span class="line">            m.m22 = 0.5f * (m.m22 + m.m32);</span><br><span class="line">            m.m23 = 0.5f * (m.m23 + m.m33);</span><br><span class="line">        </span><br><span class="line">            return m;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
    
    shadowMap 的采样有说法，详情看代码
</code></pre>
</li>
<li><p>将 surface 世界坐标转换到shaowMap坐标下（通过第三步获取的转换矩阵）</p>
</li>
<li><pre><code>// unity内置宏，对shadowmap采样
TEXTURE2D_SHADOW(_DirectionalShadowAtlas);
#define SHADOW_SAMPLER sampler_linear_clamp_compare
SAMPLER_CMP(SHADOW_SAMPLER);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   获取阴影 strength 和原 color 相乘</span><br><span class="line">*   最终结果，有严重的摩尔纹</span><br><span class="line">    *   ![image-20231023183854132](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453415.png)</span><br><span class="line"></span><br><span class="line">### 级联shadowMap</span><br><span class="line"></span><br><span class="line">*   原理</span><br><span class="line">    *   ![img](https://pic1.zhimg.com/80/v2-b592f37c6cae42255ef3b3ac99a17000_1440w.webp)</span><br><span class="line">*   ```</span><br><span class="line">    // 通过修改参数获取不同的 v,p 矩阵</span><br><span class="line">    cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(</span><br><span class="line">    light.visibleLightIndex, i, cascadeCount, ratios, tileSize, 0f,</span><br><span class="line">    out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix,</span><br><span class="line">    out ShadowSplitData splitData</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

*   ![image-20231024091425837](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453673.png)
</code></pre>
</li>
<li><p>culling sphere</p>
<ul>
<li>在确定每个级联图要渲染的实际区域时，Unity会为根据级联的阴影裁剪长方体创建一个球型空间，该球形空间会包裹整个阴影裁剪长方体，因此球形的空间会比原长方体多包裹住一些空间，这可能会导致有时在裁剪长方体区域外也会绘制一些阴影。下图为Culling Spheres的可视化图。</li>
<li>Culling Spheres的作用是让Shader确定相机渲染的每个片元需要采样哪个级联图。原理很简单，对于相机要渲染的一个片元，计算出其光源空间下的坐标，通过它计算片元与每个Culling Sphere球心的距离，最后确定属于哪个球空间内，采样对应级联图。 –</li>
<li><img src="https://catlikecoding.com/unity/tutorials/custom-srp/directional-shadows/cascaded-shadow-maps/culling-spheres.png" alt="img"></li>
</ul>
</li>
<li><pre><code>// 向shader传递 cullingSphere 参数
// cullingSphere -- x,y,z,r^2
Vector4 cullingSphere = splitData.cullingSphere;
cullingSphere.w *= cullingSphere.w;
cascadeCullingSpheres[i] = cullingSphere;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   ```</span><br><span class="line">    // 每个片元对应的 联级的信息</span><br><span class="line">    struct ShadowData &#123;</span><br><span class="line">    int cascadeIndex; // 联级索引</span><br><span class="line">    float cascadeBlend; // 和下一联级混合的比例</span><br><span class="line">    float strength;// 阴影强度</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 对阴影信息的抽象</span><br><span class="line">    struct DirectionalShadowData &#123;</span><br><span class="line">    float strength;</span><br><span class="line">    int tileIndex;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>shader 中对应关系</p>
<ul>
<li>light – DirectionalShadowData</li>
<li>frag – shadowData</li>
</ul>
</li>
<li><pre><code>// 获取具体 DirectionalShadowData -- shadowMap 索引+联级偏移量
data.tileIndex = _DirectionalLightShadowData[lightIndex].y + shadowData.cascadeIndex;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   ```</span><br><span class="line">    //通过距离判断在那个culling sphere</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; _CascadeCount; i++) &#123;</span><br><span class="line">        float4 sphere = _CascadeCullingSpheres[i];</span><br><span class="line">        float distanceSqr = DistanceSquared(surfaceWS.position, sphere.xyz);</span><br><span class="line">        if (distanceSqr &lt; sphere.w) &#123;</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    data.cascadeIndex = i;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>联级可视化</p>
<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453105.png" alt="image-20231024104421040"></li>
</ul>
</li>
<li><p>超过 maxDistence 不采样</p>
<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453161.png" alt="image-20231024105330375"></li>
</ul>
</li>
<li><p>阴影随着片元在 camera view space 深度增加而变浅 + 阴影在 max cascade 逐渐变浅</p>
<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453096.png" alt="image-20231024140333611"></li>
</ul>
</li>
</ul>
<h3 id="提升阴影质量"><a href="#提升阴影质量" class="headerlink" title="提升阴影质量"></a>提升阴影质量</h3><ul>
<li><p>shadow acne（毛刺 &amp; 阴影暗斑）</p>
<ul>
<li>原理 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366555785">关于ShadowMap中Shadow acne现象的解释</a><ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281453260.png" alt="image-20231024141014255"></li>
</ul>
</li>
<li>样例<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454585.png" alt="image-20231024141002382"></li>
</ul>
</li>
<li>Depth Bias – 添加偏移buffer.SetGlobalDepthBias(50000f, 0f); – 但是会产生阴影偏移</li>
<li>Slope Bias – buffer.SetGlobalDepthBias(0,3f); – 根据斜度进行偏移<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454961.png" alt="image-20231024141915498"></li>
</ul>
</li>
<li>由于使用联级阴影，使用全局统一的bias不合理，所以需要根据联级不同，使用不同的 culling sphere 半径做法线偏移<ul>
<li><pre><code>float3 normalBias = surfaceWS.normal * _CascadeData[global.cascadeIndex].y;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">        *   ![image-20231024151624724](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454069.png)</span><br><span class="line">*   shadow pancaking （阴影平坠 ）-- 理解的不是很好，有时间再看看</span><br><span class="line">    *   原理：[Unity 阴影——阴影平坠（Shadow pancaking](https://blog.csdn.net/ithot/article/details/125473479)</span><br><span class="line">    *   给进平面添加一个偏移</span><br><span class="line"></span><br><span class="line">### 添加 PCF</span><br><span class="line"></span><br><span class="line">*   原理：[CSM, PCSS与SDF Soft Shadow](https://zhuanlan.zhihu.com/p/478472753)</span><br><span class="line">*   float4 \_ShadowAtlasSize; //（像素大小，map尺寸，0，0）</span><br><span class="line">*   SampleShadow\_ComputeSamples\_Tent\_7x7 (size, positionSTS.xy, weights, positions);计算 PCF权重weights ，采样点positions</span><br><span class="line">    *   ```</span><br><span class="line">        // 增加采样</span><br><span class="line">        for (int i = 0; i &lt; DIRECTIONAL_FILTER_SAMPLES; i++) &#123;</span><br><span class="line">        shadow += weights[i] * SampleDirectionalShadowAtlas(</span><br><span class="line">        float3(positions[i].xy, positionSTS.z)</span><br><span class="line">        );</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>buffer.EnableShaderKeyword( string ) &#x2F;&#x2F; 向shader添加关键字，常用于定义宏</p>
</li>
<li><p>联级过渡出现问题</p>
<ul>
<li><img src="https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454840.png" alt="image-20231024214954538"></li>
<li>添加联级之间混合，效果好了，但是增加了采样次数<ul>
<li><pre><code>if (global.cascadeBlend &lt; 1.0) &#123;
normalBias = surfaceWS.normal *
(directional.normalBias * _CascadeData[global.cascadeIndex + 1].y);
positionSTS = mul(
_DirectionalShadowMatrices[directional.tileIndex + 1],
float4(surfaceWS.position + normalBias, 1.0)
).xyz;
// 联级之间根据
shadow = lerp(
FilterDirectionalShadow(positionSTS), shadow, global.cascadeBlend
);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   在采样时添加抖动</span><br><span class="line">    *   surface.dither = InterleavedGradientNoise(input.positionCS.xy, 0); //生成时间梯度噪声</span><br><span class="line">*   绘制 shadowMap 时不绘制在当前联级之外的物体</span><br><span class="line">    *   ```</span><br><span class="line">        splitData.shadowCascadeBlendCullingFactor = cullingFactor</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="阴影裁剪"><a href="#阴影裁剪" class="headerlink" title="阴影裁剪"></a>阴影裁剪</h3><ul>
<li><pre><code>// shadow caster 中裁剪
#if defined(_SHADOWS_CLIP)
  clip(base.r - UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff));
#endif
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   ![image-20231028143015906](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454867.png)</span><br><span class="line"></span><br><span class="line">![image-20231028144052590](https://aolixin-typora-image.oss-cn-beijing.aliyuncs.com/image202310281454629.png)</span><br><span class="line"></span><br><span class="line">## 其他</span><br><span class="line"></span><br><span class="line">### unity Input</span><br><span class="line"></span><br><span class="line">*   buffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);) 设置矩阵，然后unity Input把这个矩阵放到shader里面</span><br><span class="line"></span><br><span class="line">### unity中real变量</span><br><span class="line"></span><br><span class="line">*   unity core RP Pipline Library real -- 根据不同平台成为float或half，定义在com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl</span><br><span class="line"></span><br><span class="line">### Premultiplied Alpha (Alpha预乘)</span><br><span class="line"></span><br><span class="line">[Premultiplied Alpha到底是干嘛用的](https://blog.csdn.net/mydreamremindme/article/details/50817294) [Premultiplied Alpha Tips](https://zhuanlan.zhihu.com/p/344751308) 实现</span><br><span class="line"></span><br><span class="line">*   ```</span><br><span class="line">    // alpha 预乘</span><br><span class="line">      if (applyAlphaToDiffuse) &#123;</span><br><span class="line">      brdf.diffuse *= surface.alpha;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="unity-default"><a href="#unity-default" class="headerlink" title="unity default"></a>unity default</h3><p><code>default</code> 值的含义取决于 <code>ShadowSettings</code> 类型的定义。如果 <code>ShadowSettings</code> 是一个自定义结构或类，那么它的默认值将取决于它的构造函数或字段默认值。这样，<code>shadows</code> 字段将在Inspector中显示，并且其初始值将设置为 <code>ShadowSettings</code> 类型的默认值。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2023/11/01/lua%20%E5%88%A4%E7%A9%BAbug/" rel="next" title="xlua 和 unity 判空踩的坑">
      xlua 和 unity 判空踩的坑 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#srp%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="nav-text">srp渲染流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#drawingSettings"><span class="nav-text">drawingSettings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScriptableCullingParameters"><span class="nav-text">ScriptableCullingParameters</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#srp-%E4%B8%ADugui%E7%BB%98%E5%88%B6"><span class="nav-text">srp 中ugui绘制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unity-%E6%89%B9%E5%A4%84%E7%90%86-Unity%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E7%9A%844%E7%A7%8D%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-text">unity 批处理 Unity渲染优化的4种批处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SRP-batcher"><span class="nav-text">SRP batcher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GPU-Instancing"><span class="nav-text">GPU Instancing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#srp-%E5%AE%9E%E7%8E%B0"><span class="nav-text">srp 实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#srp-batcher%E5%92%8C-GPU-Instancing%E5%8C%BA%E5%88%AB"><span class="nav-text">srp batcher和 GPU Instancing区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamic-Batching"><span class="nav-text">Dynamic Batching</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shadows"><span class="nav-text">Shadows</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9B%BE"><span class="nav-text">类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90shadowMap"><span class="nav-text">生成shadowMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8D%87%E9%98%B4%E5%BD%B1%E8%B4%A8%E9%87%8F"><span class="nav-text">提升阴影质量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B4%E5%BD%B1%E8%A3%81%E5%89%AA"><span class="nav-text">阴影裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unity-default"><span class="nav-text">unity default</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aolixin"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aolixin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aolixin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aolixin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2876589230@qq.com" title="E-Mail → mailto:2876589230@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aolixin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">36k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">33 mins.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
